[{"E:\\New folder\\pipes-task\\pipes-task\\src\\index.tsx":"1","E:\\New folder\\pipes-task\\pipes-task\\src\\reportWebVitals.ts":"2","E:\\New folder\\pipes-task\\pipes-task\\src\\App.tsx":"3","E:\\New folder\\pipes-task\\pipes-task\\src\\engine.ts":"4","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\options\\Options.tsx":"5","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\header\\Header.tsx":"6","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\rules\\Rules.tsx":"7","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\history\\History.tsx":"8","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\cell\\Cell.tsx":"9","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\fancyGrid\\FancyGrid.tsx":"10","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\simpleGrid\\SimpleGrid.tsx":"11","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\spinner\\Spinner.tsx":"12","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\slider\\Slider.tsx":"13","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\button\\Button.tsx":"14"},{"size":296,"mtime":1614208786438,"results":"15","hashOfConfig":"16"},{"size":425,"mtime":499158900000,"results":"17","hashOfConfig":"16"},{"size":8591,"mtime":1614432764518,"results":"18","hashOfConfig":"16"},{"size":19457,"mtime":1614332397540,"results":"19","hashOfConfig":"16"},{"size":2064,"mtime":1614433606434,"results":"20","hashOfConfig":"16"},{"size":1123,"mtime":1614425837163,"results":"21","hashOfConfig":"16"},{"size":1430,"mtime":1614433002786,"results":"22","hashOfConfig":"16"},{"size":1551,"mtime":1614425837116,"results":"23","hashOfConfig":"16"},{"size":1059,"mtime":1614274290679,"results":"24","hashOfConfig":"16"},{"size":1930,"mtime":1614428123290,"results":"25","hashOfConfig":"16"},{"size":2101,"mtime":1614433445322,"results":"26","hashOfConfig":"16"},{"size":558,"mtime":1614336097575,"results":"27","hashOfConfig":"16"},{"size":794,"mtime":1614431873439,"results":"28","hashOfConfig":"16"},{"size":699,"mtime":1614266727175,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"1ctwnvw",{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"37","messages":"38","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39","usedDeprecatedRules":"32"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"E:\\New folder\\pipes-task\\pipes-task\\src\\index.tsx",[],["60","61"],"E:\\New folder\\pipes-task\\pipes-task\\src\\reportWebVitals.ts",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\App.tsx",["62"],"E:\\New folder\\pipes-task\\pipes-task\\src\\engine.ts",["63"],"export interface Pipe {\r\n  name: ShapeName;\r\n  top: boolean;\r\n  right: boolean;\r\n  bottom: boolean;\r\n  left: boolean;\r\n  isDone: boolean;\r\n  allowedPositions: Position[];\r\n  position: Position;\r\n}\r\n\r\nexport type Position = 0 | 90 | 180 | 270;\r\n\r\nexport type Direction = \"top\" | \"right\" | \"bottom\" | \"left\";\r\n\r\nexport type ShapeType =\r\n  | \"┏\"\r\n  | \"┓\"\r\n  | \"┗\"\r\n  | \"┛\"\r\n  | \"╸\"\r\n  | \"╺\"\r\n  | \"╹\"\r\n  | \"╻\"\r\n  | \"┣\"\r\n  | \"┳\"\r\n  | \"┻\"\r\n  | \"┫\"\r\n  | \"━\"\r\n  | \"┃\"\r\n  | \"╋\";\r\n\r\ntype ShapeName = \"Line\" | \"Elbow\" | \"Tee\" | \"End\" | \"Cross\" ;\r\n\r\ninterface Output  {\r\n  rotateMessage: string , pipesLeft: number\r\n}\r\n\r\nexport const splitRawDataInShapeRows = (\r\n  mapAsString: string,\r\n): string[] => {\r\n  const legitMapData = mapAsString.split(\"\\n\");\r\n    legitMapData.shift();\r\n    legitMapData.pop();\r\n  return legitMapData;\r\n};\r\n\r\nexport const makeShapeGridFromRows = (rows: string[]): ShapeType[][] => {\r\n  const output: ShapeType[][] = rows.map((row) => {\r\n    return row.split(\"\") as ShapeType[];\r\n  });\r\n  return output;\r\n};\r\n\r\nexport const initNewPipe = (\r\n  name: ShapeName,\r\n  top: boolean,\r\n  right: boolean,\r\n  bottom: boolean,\r\n  left: boolean,\r\n  position: Position,\r\n): Pipe => {\r\n  return {\r\n    name,\r\n    top,\r\n    right,\r\n    bottom,\r\n    left,\r\n    position,\r\n    isDone: name === \"Cross\" ? true : false,\r\n    allowedPositions: name === \"Cross\" ? [0] : [0, 90, 180, 270],\r\n  };\r\n};\r\n\r\nexport const translateFromShapeToPipe = (\r\n  shape: ShapeType\r\n): Pipe => {\r\n  switch (shape) {\r\n    case \"┗\": {\r\n      return initNewPipe(\"Elbow\", true, true, false, false, 0);\r\n    }\r\n    case \"┏\": {\r\n      return initNewPipe(\"Elbow\", false, true, true, false, 90);\r\n    }\r\n    case \"┓\": {\r\n      return initNewPipe(\"Elbow\", false, false, true, true, 180);\r\n    }\r\n    case \"┛\": {\r\n      return initNewPipe(\"Elbow\", true, false, false, true, 270);\r\n    }\r\n    case \"╸\": {\r\n      return initNewPipe(\"End\", false, false, false, true, 270);\r\n    }\r\n    case \"╹\": {\r\n      return initNewPipe(\"End\", true, false, false, false, 0);\r\n    }\r\n    case \"╻\": {\r\n      return initNewPipe(\"End\", false, false, true, false, 180);\r\n    }\r\n    case \"╺\": {\r\n      return initNewPipe(\"End\", false, true, false, false, 90);\r\n    }\r\n    case \"┣\": {\r\n      return initNewPipe(\"Tee\", true, true, true, false, 90);\r\n    }\r\n    case \"┳\": {\r\n      return initNewPipe(\"Tee\", false, true, true, true, 180);\r\n    }\r\n    case \"┻\": {\r\n      return initNewPipe(\"Tee\", true, true, false, true, 0);\r\n    }\r\n    case \"┫\": {\r\n      return initNewPipe(\"Tee\", true, false, true, true, 270);\r\n    }\r\n    case \"━\": {\r\n      return initNewPipe(\"Line\", false, true, false, true, 90);\r\n    }\r\n    case \"┃\": {\r\n      return initNewPipe(\"Line\", true, false, true, false, 0);\r\n    }\r\n    case \"╋\": {\r\n      return initNewPipe(\"Cross\", true, true, true, true, 0);\r\n    }\r\n    default: {\r\n      return initNewPipe(\"Cross\", false, false, false, false, 0);\r\n    }\r\n  }\r\n};\r\nexport const translatePipeToShape = (pipe: Pipe): ShapeType => {\r\n  const { top, right, bottom, left } = pipe;\r\n  const pipePositions = [top, right, bottom, left];\r\n  switch (JSON.stringify(pipePositions)) {\r\n    case JSON.stringify([false, true, true, false]):\r\n      return \"┏\";\r\n    case JSON.stringify([false, false, true, true]):\r\n      return \"┓\";\r\n    case JSON.stringify([true, false, false, true]):\r\n      return \"┛\";\r\n    case JSON.stringify([true, true, false, false]):\r\n      return \"┗\";\r\n    case JSON.stringify([true, false, true, false]):\r\n      return \"┃\";\r\n    case JSON.stringify([false, true, false, true]):\r\n      return \"━\";\r\n    case JSON.stringify([true, false, true, true]):\r\n      return \"┫\";\r\n    case JSON.stringify([true, true, true, false]):\r\n      return \"┣\";\r\n    case JSON.stringify([true, true, false, true]):\r\n      return \"┻\";\r\n    case JSON.stringify([false, true, true, true]):\r\n      return \"┳\";\r\n    case JSON.stringify([false, false, false, true]):\r\n      return \"╸\";\r\n    case JSON.stringify([false, false, true, false]):\r\n      return \"╻\";\r\n    case JSON.stringify([false, true, false, false]):\r\n      return \"╺\";\r\n    case JSON.stringify([true, false, false, false]):\r\n      return \"╹\";\r\n    default:\r\n      return \"╋\";\r\n  }\r\n};\r\n\r\nexport const transformShapeGridToPipeGrid = (\r\n  shapeGrid: ShapeType[][]\r\n): Pipe[][] => {\r\n  const output = shapeGrid.map((row) => {\r\n    return row.map((shape) => {\r\n      return translateFromShapeToPipe(shape);\r\n    });\r\n  });\r\n  return output;\r\n};\r\n\r\nexport const rotatePipe = (pipe: Pipe): Pipe => {\r\n  const output = { ...pipe };\r\n  output.top = pipe.left;\r\n  output.left = pipe.bottom;\r\n  output.bottom = pipe.right;\r\n  output.right = pipe.top;\r\n  if (output.position > 200) {\r\n    output.position = 0;\r\n  } else {\r\n    output.position += 90;\r\n  }\r\n  return output;\r\n};\r\n\r\nexport const appendRotateMessage = (\r\n  base: string,\r\n  x: number,\r\n  y: number\r\n): string => {\r\n  if (base.length > 8) {\r\n    return (base += `\\n${x} ${y}`);\r\n  }\r\n  return (base += ` ${x} ${y}`);\r\n};\r\n\r\nexport const calculateRotationCount = (\r\n  positionNow: Position,\r\n  desiredPosition: Position\r\n): number => {\r\n  let output = 0;\r\n  let tmp = positionNow;\r\n  while (tmp !== desiredPosition) {\r\n    output += 1;\r\n    if (tmp > 200) {\r\n      tmp = 0;\r\n    } else {\r\n      tmp += 90;\r\n    }\r\n  }\r\n  return output;\r\n};\r\n\r\n// Check if pipe must be NOT connected given direction even if it's not done\r\nexport const mustBeNotConnected = (\r\n  x: number,\r\n  y: number,\r\n  direction: Direction,\r\n  grid: Pipe[][]\r\n): boolean => {\r\n  const pipe = grid[y][x];\r\n  // if all pipes posotions possible, then it's not certain and return false\r\n  if (pipe.allowedPositions.length > 3) return false;\r\n\r\n  let output = true;\r\n  const positionNow = pipe.position;\r\n  pipe.allowedPositions.forEach((posAllowed) => {\r\n    const count = calculateRotationCount(positionNow, posAllowed);\r\n    let tmpPipe = { ...pipe };\r\n    for (let i = 0; i < count; i++) {\r\n      tmpPipe = rotatePipe(tmpPipe);\r\n    }\r\n    if (tmpPipe[direction]) output = false;\r\n  });\r\n  return output;\r\n};\r\n\r\n// Check if pipe must be connected given direction even if it's not done\r\nexport const mustBeConnected = (\r\n  x: number,\r\n  y: number,\r\n  direction: Direction,\r\n  grid: Pipe[][]\r\n): boolean => {\r\n  const pipe = grid[y][x];\r\n\r\n  if (pipe.allowedPositions.length > 3) return false;\r\n\r\n  let output = true;\r\n  const positionNow = pipe.position;\r\n  pipe.allowedPositions.forEach((posAllowed) => {\r\n    const count = calculateRotationCount(positionNow, posAllowed);\r\n    let tmpPipe = { ...pipe };\r\n    for (let i = 0; i < count; i++) {\r\n      tmpPipe = rotatePipe(tmpPipe);\r\n    }\r\n    if (!tmpPipe[direction]) output = false;\r\n  });\r\n\r\n  return output;\r\n};\r\n\r\n// Removes given positions from positions array and returns updated positions array\r\nexport const spliceOutPositions = (\r\n  allowdPositons: Position[],\r\n  ...positionsToRemove: Position[]\r\n): Position[] => {\r\n  const output = [...allowdPositons];\r\n  positionsToRemove.forEach((pos) => {\r\n    const idx = output.indexOf(pos);\r\n    if (idx > -1) output.splice(idx, 1);\r\n  });\r\n  return output;\r\n};\r\n\r\n// --------------- CHECK LINE SHAPE -------------\r\n\r\nexport const checkLeft_Line = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const leftPipe = grid[y][x - 1];\r\n  // If there is no pipe on the left, reduce to single possible position\r\n  if (!leftPipe) return [0];\r\n  // If left pipe does not allow right connection, reduce to single possible position\r\n  if (mustBeNotConnected(x - 1, y, \"right\", grid)) return [0];\r\n  // If left pipe must have right connection, reduce to single possible position\r\n  if (mustBeConnected(x - 1, y, \"right\", grid)) return [90];\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkRight_Line = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const rightPipe = grid[y][x + 1];\r\n  if (!rightPipe) return [0];\r\n  if (mustBeConnected(x + 1, y, \"left\", grid)) return [90];\r\n  if (mustBeNotConnected(x + 1, y, \"left\", grid)) return [0];\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkTop_Line = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y - 1 < 0) return [90];\r\n  if (mustBeConnected(x, y - 1, \"bottom\", grid)) return [0];\r\n  if (mustBeNotConnected(x, y - 1, \"bottom\", grid)) return [90];\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkBottom_Line = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y + 1 >= grid.length) return [90];\r\n  if (mustBeConnected(x, y + 1, \"top\", grid)) return [0];\r\n  if (mustBeNotConnected(x, y + 1, \"top\", grid)) return [90];\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\n// --------------- CHECK TEE SHAPE -------------\r\n\r\nexport const checkLeft_Tee = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const leftPipe = grid[y][x - 1];\r\n  // If there is no pipe on the left, reduce to single possible position\r\n  if (!leftPipe) return [90];\r\n  // If left pipe does not allow right connection, reduce to single possible position\r\n  if (mustBeNotConnected(x - 1, y, \"right\", grid)) return [90];\r\n  // If left pipe must have right connection, slice out one not possible connection\r\n  if (mustBeConnected(x - 1, y, \"right\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkRight_Tee = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const rightPipe = grid[y][x + 1];\r\n  if (!rightPipe) return [270];\r\n  if (mustBeNotConnected(x + 1, y, \"left\", grid)) return [270];\r\n  if (mustBeConnected(x + 1, y, \"left\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 270);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkTop_Tee = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y - 1 < 0) return [180];\r\n  if (mustBeNotConnected(x, y - 1, \"bottom\", grid)) return [180];\r\n  if (mustBeConnected(x, y - 1, \"bottom\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkBottom_Tee = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y + 1 >= grid.length) return [0];\r\n  if (mustBeNotConnected(x, y + 1, \"top\", grid)) return [0];\r\n  if (mustBeConnected(x, y + 1, \"top\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\n// --------------- CHECK END SHAPE -------------\r\n\r\nexport const checkLeft_End = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const leftPipe = grid[y][x - 1];\r\n  // If there is no pipe on the left, slice out one not possible position\r\n  if (!leftPipe) return spliceOutPositions(grid[y][x].allowedPositions, 270);\r\n  // If left pipe must NOT be connected to right, slice out one not possible position\r\n  if (mustBeNotConnected(x - 1, y, \"right\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 270);\r\n  // If left pipe must be connected to right, reduce to one possible connection\r\n  if (mustBeConnected(x - 1, y, \"right\", grid)) return [270];\r\n  // If left pipe is End too, slice out one not possible direction\r\n  else if (leftPipe.name === \"End\")\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 270);\r\n  // if no pattern found\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkRight_End = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const rightPipe = grid[y][x + 1];\r\n  if (!rightPipe) return spliceOutPositions(grid[y][x].allowedPositions, 90);\r\n  if (mustBeNotConnected(x + 1, y, \"left\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90);\r\n  if (mustBeConnected(x + 1, y, \"left\", grid)) return [90];\r\n  else if (rightPipe.name === \"End\")\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkTop_End = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y - 1 < 0) return spliceOutPositions(grid[y][x].allowedPositions, 0);\r\n  if (mustBeNotConnected(x, y - 1, \"bottom\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0);\r\n  if (mustBeConnected(x, y - 1, \"bottom\", grid)) return [0];\r\n  else if (grid[y - 1][x].name === \"End\")\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkBottom_End = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y + 1 >= grid.length)\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180);\r\n  if (mustBeNotConnected(x, y + 1, \"top\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180);\r\n  if (mustBeConnected(x, y + 1, \"top\", grid)) return [180];\r\n  else if (grid[y + 1][x].name === \"End\")\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\n// --------------- CHECK ELBOW SHAPE -------------\r\n\r\nexport const checkLeft_Elbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const leftPipe = grid[y][x - 1];\r\n  // If there is no pipe on the left, slice out two not possible positions\r\n  if (!leftPipe)\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180, 270);\r\n  // If left pipe cant have right connection, slice out two not possible positions\r\n  if (mustBeNotConnected(x - 1, y, \"right\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180, 270);\r\n  // If left pipe must have right connection, slice out two not possible positions\r\n  if (mustBeConnected(x - 1, y, \"right\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0, 90);\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkRight_Elbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const rightPipe = grid[y][x + 1];\r\n  if (!rightPipe) return spliceOutPositions(grid[y][x].allowedPositions, 0, 90);\r\n  if (mustBeNotConnected(x + 1, y, \"left\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0, 90);\r\n  if (mustBeConnected(x + 1, y, \"left\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180, 270);\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkTop_Elbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y - 1 < 0) return spliceOutPositions(grid[y][x].allowedPositions, 0, 270);\r\n  if (mustBeNotConnected(x, y - 1, \"bottom\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0, 270);\r\n  if (mustBeConnected(x, y - 1, \"bottom\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90, 180);\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkBottom_Elbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y + 1 >= grid.length)\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90, 180);\r\n  if (mustBeNotConnected(x, y + 1, \"top\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90, 180);\r\n  if (mustBeConnected(x, y + 1, \"top\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0, 270);\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\n\r\nexport const solvePipe = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][],\r\n  rotateMsg: string,\r\n  pipesToSolve: number\r\n\r\n): Output => {\r\n  let output = rotateMsg;\r\n  let pipesLeft = pipesToSolve;\r\n\r\n  \r\n  const count = calculateRotationCount(\r\n    grid[y][x].position,\r\n    grid[y][x].allowedPositions[0]\r\n  );\r\n  for (let i = 0; i < count; i++) {\r\n    grid[y][x] = rotatePipe(grid[y][x]);\r\n    // message @ end\r\n    output = appendRotateMessage(output, x, y);\r\n  }\r\n  grid[y][x].isDone = true;\r\n  pipesLeft -=1;\r\n  \r\n  const outputObj = {rotateMessage: output , pipesLeft}\r\n  return outputObj\r\n};\r\n\r\n\r\nconst isDoneAndConnectedSpecificDirection = (\r\n  x: number,\r\n  y: number,\r\n  direction: Direction,\r\n  grid: Pipe[][]\r\n) => {\r\n  // If passed not legit coordinates\r\n  if (x < 0 || y < 0 || x >= grid[0].length || y >= grid.length) return false;\r\n  // If pipe is not done\r\n  if (!grid[y][x].isDone) return false;\r\n  // if pipe is connected given direction\r\n  if (grid[y][x][direction]) return true;\r\n  // else false\r\n  return false;\r\n};\r\n\r\nconst checkLine = (x: number, y: number, grid: Pipe[][], rotateMsg: string, pipesToSolve:number):Output => {\r\n  let output = rotateMsg;\r\n  grid[y][x].allowedPositions = checkLeft_Line(x, y, grid);\r\n  grid[y][x].allowedPositions = checkRight_Line(x, y, grid);\r\n  grid[y][x].allowedPositions = checkTop_Line(x, y, grid);\r\n  grid[y][x].allowedPositions = checkBottom_Line(x, y, grid);\r\n  if (grid[y][x].allowedPositions.length === 1) {\r\n     return  solvePipe(x, y, grid, output, pipesToSolve);\r\n  }\r\n  const outputObj =  {rotateMessage: output , pipesLeft: pipesToSolve}\r\n  return outputObj\r\n};\r\n\r\nconst checkTee = (x: number, y: number, grid: Pipe[][], rotateMsg: string, pipesToSolve:number):Output => {\r\n  let output = rotateMsg;\r\n  grid[y][x].allowedPositions = checkLeft_Tee(x, y, grid);\r\n  grid[y][x].allowedPositions = checkRight_Tee(x, y, grid);\r\n  grid[y][x].allowedPositions = checkTop_Tee(x, y, grid);\r\n  grid[y][x].allowedPositions = checkBottom_Tee(x, y, grid);\r\n  if (grid[y][x].allowedPositions.length === 1) {\r\n     return  solvePipe(x, y, grid, output, pipesToSolve);\r\n  }\r\n  const outputObj =  {rotateMessage: output , pipesLeft: pipesToSolve}\r\n  return outputObj\r\n};\r\n\r\nconst checkEnd = (x: number, y: number, grid: Pipe[][], rotateMsg: string, pipesToSolve:number) => {\r\n  let output = rotateMsg;\r\n  grid[y][x].allowedPositions = checkLeft_End(x, y, grid);\r\n  grid[y][x].allowedPositions = checkRight_End(x, y, grid);\r\n  grid[y][x].allowedPositions = checkTop_End(x, y, grid);\r\n  grid[y][x].allowedPositions = checkBottom_End(x, y, grid);\r\n  if (grid[y][x].allowedPositions.length === 1) {\r\n     return  solvePipe(x, y, grid, output, pipesToSolve);\r\n  }\r\n  const outputObj =  {rotateMessage: output , pipesLeft: pipesToSolve}\r\n  return outputObj\r\n};\r\n\r\nconst checkElbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][],\r\n  rotateMsg: string, \r\n  pipesToSolve:number\r\n) => {\r\n  let output = rotateMsg;\r\n  grid[y][x].allowedPositions = checkLeft_Elbow(x, y, grid);\r\n  grid[y][x].allowedPositions = checkRight_Elbow(x, y, grid);\r\n  grid[y][x].allowedPositions = checkTop_Elbow(x, y, grid);\r\n  grid[y][x].allowedPositions = checkBottom_Elbow(x, y, grid);\r\n  if (grid[y][x].allowedPositions.length === 1) {\r\n    return  solvePipe(x, y, grid, output, pipesToSolve);\r\n  }\r\n  const outputObj =  {rotateMessage: output , pipesLeft: pipesToSolve}\r\n  return outputObj\r\n};\r\n\r\nexport const checkPipe = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][],\r\n  rotateMsg: string,\r\n  pipesToSolve : number\r\n): {rotateMessage : string, pipesLeft : number} => {\r\n  switch (grid[y][x].name) {\r\n    case \"Line\": {\r\n      return checkLine(x, y, grid, rotateMsg, pipesToSolve);\r\n    }\r\n    case \"Tee\": {\r\n      return checkTee(x, y, grid, rotateMsg, pipesToSolve);\r\n    }\r\n    case \"End\": {\r\n      return checkEnd(x, y, grid, rotateMsg, pipesToSolve);\r\n    }\r\n    case \"Elbow\": {\r\n      return checkElbow(x, y, grid, rotateMsg, pipesToSolve);\r\n    }\r\n    default: {\r\n      const outputObj =  {rotateMessage: rotateMsg , pipesLeft: pipesToSolve}\r\n      return outputObj\r\n    }\r\n  }\r\n};\r\n","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\options\\Options.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\header\\Header.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\rules\\Rules.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\history\\History.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\cell\\Cell.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\fancyGrid\\FancyGrid.tsx",["64"],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\simpleGrid\\SimpleGrid.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\spinner\\Spinner.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\slider\\Slider.tsx",["65"],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\button\\Button.tsx",[],{"ruleId":"66","replacedBy":"67"},{"ruleId":"68","replacedBy":"69"},{"ruleId":"70","severity":1,"message":"71","line":131,"column":6,"nodeType":"72","endLine":131,"endColumn":26,"suggestions":"73"},{"ruleId":"74","severity":1,"message":"75","line":549,"column":7,"nodeType":"76","messageId":"77","endLine":549,"endColumn":42},{"ruleId":"74","severity":1,"message":"78","line":5,"column":8,"nodeType":"76","messageId":"77","endLine":5,"endColumn":14},{"ruleId":"74","severity":1,"message":"79","line":1,"column":21,"nodeType":"76","messageId":"77","endLine":1,"endColumn":29},"no-native-reassign",["80"],"no-negated-in-lhs",["81"],"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'autoSolveTime', 'grid', 'history', and 'stopAutoSolve'. Either include them or remove the dependency array.","ArrayExpression",["82"],"@typescript-eslint/no-unused-vars","'isDoneAndConnectedSpecificDirection' is assigned a value but never used.","Identifier","unusedVar","'Slider' is defined but never used.","'useState' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"83","fix":"84"},"Update the dependencies array to be: [counter, autoSolve, grid, autoSolveTime, history, stopAutoSolve]",{"range":"85","text":"86"},[3575,3595],"[counter, autoSolve, grid, autoSolveTime, history, stopAutoSolve]"]
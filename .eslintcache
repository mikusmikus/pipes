[{"E:\\New folder\\pipes-task\\pipes-task\\src\\index.tsx":"1","E:\\New folder\\pipes-task\\pipes-task\\src\\reportWebVitals.ts":"2","E:\\New folder\\pipes-task\\pipes-task\\src\\App.tsx":"3","E:\\New folder\\pipes-task\\pipes-task\\src\\engine.ts":"4","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\options\\Options.tsx":"5","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\header\\Header.tsx":"6","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\rules\\Rules.tsx":"7","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\history\\History.tsx":"8","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\cell\\Cell.tsx":"9","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\fancyGrid\\FancyGrid.tsx":"10","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\simpleGrid\\SimpleGrid.tsx":"11","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\spinner\\Spinner.tsx":"12","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\slider\\Slider.tsx":"13","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\button\\Button.tsx":"14"},{"size":296,"mtime":1614208786438,"results":"15","hashOfConfig":"16"},{"size":425,"mtime":499158900000,"results":"17","hashOfConfig":"16"},{"size":8591,"mtime":1614432764518,"results":"18","hashOfConfig":"16"},{"size":19461,"mtime":1614433896643,"results":"19","hashOfConfig":"16"},{"size":2064,"mtime":1614433606434,"results":"20","hashOfConfig":"16"},{"size":1123,"mtime":1614425837163,"results":"21","hashOfConfig":"16"},{"size":1430,"mtime":1614433002786,"results":"22","hashOfConfig":"16"},{"size":1551,"mtime":1614425837116,"results":"23","hashOfConfig":"16"},{"size":1059,"mtime":1614274290679,"results":"24","hashOfConfig":"16"},{"size":1930,"mtime":1614428123290,"results":"25","hashOfConfig":"16"},{"size":2109,"mtime":1614433928580,"results":"26","hashOfConfig":"16"},{"size":558,"mtime":1614336097575,"results":"27","hashOfConfig":"16"},{"size":794,"mtime":1614431873439,"results":"28","hashOfConfig":"16"},{"size":699,"mtime":1614266727175,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"1ctwnvw",{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"32"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"32"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"32"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61","usedDeprecatedRules":"32"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"E:\\New folder\\pipes-task\\pipes-task\\src\\index.tsx",[],["64","65"],"E:\\New folder\\pipes-task\\pipes-task\\src\\reportWebVitals.ts",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\App.tsx",["66"],"/* eslint-disable @typescript-eslint/no-use-before-define */\nimport React, { useEffect, useRef, useState } from \"react\";\nimport { w3cwebsocket } from \"websocket\";\nimport {\n  Pipe,\n  makeShapeGridFromRows,\n  splitRawDataInShapeRows,\n  transformShapeGridToPipeGrid,\n  rotatePipe,\n  appendRotateMessage,\n  checkPipe,\n} from \"./engine\";\nimport Options from \"./components/options/Options\";\nimport Heading from \"./components/header/Header\";\nimport History from \"./components/history/History\";\nimport FancyGrid from \"./components/fancyGrid/FancyGrid\";\nimport SimpleGrid from \"./components/simpleGrid/SimpleGrid\";\nimport Slider from \"./components/slider/Slider\";\n\nexport interface WhatRender {\n  levelsBtns: boolean;\n  fancyGrid: boolean;\n  startGame: boolean;\n  startSolveBtn: boolean;\n  stopSolveBtn: boolean;\n  simpleGrid: boolean;\n  restartBtn: boolean;\n  verify: boolean;\n  info: boolean;\n}\nconst client = new w3cwebsocket(\"ws://hometask.eg1236.com/game-pipes/\");\n\nclient.onopen = () => {\n  console.log(\"Connected\");\n};\n\nconst levels = [1, 2, 3, 4, 5, 6];\n\nlet cellWidth = \"\";\n\nfunction App() {\n  const [grid, setGrid] = useState<Pipe[][]>([]);\n  const [history, setHistory] = useState(\"rotate\");\n  const [counter, setCounter] = useState(0);\n  const [autoSolve, setAutoSolve] = useState(false);\n  const [verifyMsg, setVerifyMsg] = useState(\"\");\n  const [autoSolveTime, setAutoSolveTime] = useState(2);\n  const [whatRender, setWhatRender] = useState({\n    levelsBtns: true,\n    fancyGrid: false,\n    simpleGrid: false,\n    startGame: false,\n    startSolveBtn: false,\n    stopSolveBtn: false,\n    restartBtn: false,\n    verify: false,\n    info: true,\n  });\n\n  const timeOut = useRef<NodeJS.Timeout>();\n  const mapAsString = useRef(\"\");\n  const xx = useRef(0);\n  const yy = useRef(0);\n  const rotateCount = useRef(0);\n  const totalPipes = useRef(0);\n  const pipesToSolve = useRef(0);\n  const currentLevel = useRef(0);\n\n  client.onmessage = (msg) => {\n    const info: string = msg.data as string;\n    console.log(\"info\", info);\n    if (info.startsWith(\"verify: Correct\")) {\n      setVerifyMsg(info);\n    }\n    if (info.startsWith(\"verify: Incorrect\")) {\n      setVerifyMsg(`${info} Something is not connecting right, keep solving`);\n    }\n    mapAsString.current = info;\n  };\n  // console.log(\"mapAsString.current\", mapAsString.current);\n\n  useEffect(() => {\n    if (grid.length && autoSolve) {\n      let loopCountLeft = totalPipes.current;\n      let keepLooping = true;\n      do {\n        if (counter) {\n          xx.current += 1;\n        }\n        if (xx.current >= grid[0].length) {\n          xx.current = 0;\n          yy.current += 1;\n        }\n        if (yy.current >= grid.length) {\n          yy.current = 0;\n          xx.current = 0;\n        }\n\n        if (!grid[yy.current][xx.current].isDone) {\n          keepLooping = false;\n        }\n\n        loopCountLeft -= 1;\n        if (loopCountLeft < 0) {\n          keepLooping = false;\n        }\n      } while (keepLooping);\n\n      timeOut.current = setTimeout(() => {\n        const { rotateMessage, pipesLeft } = checkPipe(\n          xx.current,\n          yy.current,\n          grid,\n          history,\n          pipesToSolve.current\n        );\n\n        if (rotateMessage.length !== history.length) {\n          rotateCount.current = counter;\n          setHistory(rotateMessage);\n        }\n\n        pipesToSolve.current = pipesLeft;\n        if (counter - rotateCount.current > pipesToSolve.current) {\n          stopAutoSolve();\n          return;\n        }\n        setCounter(counter + 1);\n      }, autoSolveTime*200);\n    }\n  }, [counter, autoSolve]);\n\n\n\n  const setLevel = (level: number) => {\n    client.send(`new ${level}`);\n    client.send(\"map\");\n    currentLevel.current = level;\n    setWhatRender({\n      ...whatRender,\n      levelsBtns: false,\n      startGame: true,\n      restartBtn: true,\n    });\n  };\n\n  const startGame = () => {\n    const step1 = splitRawDataInShapeRows(mapAsString.current);\n    const step2 = makeShapeGridFromRows(step1);\n    const step3 = transformShapeGridToPipeGrid(step2);\n    totalPipes.current = step3.length * step3[0].length;\n    cellWidth = `${100 / step2[0].length}%`;\n    pipesToSolve.current = totalPipes.current;\n    setGrid(step3);\n    setHistory(\"rotate\");\n    if (currentLevel.current <= 3) {\n      setWhatRender({\n        ...whatRender,\n        startGame: false,\n        restartBtn: true,\n        startSolveBtn: true,\n        fancyGrid: true,\n        verify: true,\n      });\n    } else {\n      setWhatRender({\n        ...whatRender,\n        startGame: false,\n        restartBtn: true,\n        startSolveBtn: true,\n        // simpleGrid: true,\n        verify: true,\n      });\n    }\n  };\n\n  const restartGame = () => {\n    setHistory(\"rotate\");\n    setCounter(0);\n    xx.current = 0;\n    yy.current = 0;\n    clearTimeout(timeOut.current!);\n    setAutoSolve(false);\n    setVerifyMsg(\"\");\n    setWhatRender({\n      ...whatRender,\n      levelsBtns: true,\n      startGame: false,\n      restartBtn: false,\n      startSolveBtn: false,\n      stopSolveBtn: false,\n      fancyGrid: false,\n      simpleGrid: false,\n      verify: false,\n    });\n  };\n\n  const startAutoSolve = () => {\n    rotateCount.current = counter;\n\n    if (currentLevel.current > 2) {\n      setAutoSolveTime(0);\n    }\n\n    setAutoSolve(true);\n    setVerifyMsg(\"\");\n    setWhatRender({\n      ...whatRender,\n      startSolveBtn: false,\n      stopSolveBtn: true,\n      verify: false,\n      simpleGrid: false,\n    });\n  };\n\n  const stopAutoSolve = () => {\n    clearTimeout(timeOut.current!);\n    setAutoSolve(false);\n    setWhatRender({\n      ...whatRender,\n      startSolveBtn: true,\n      stopSolveBtn: false,\n      verify: true,\n    });\n  };\n\n  const cellClickHandler = (x: number, y: number, pipe?: Pipe) => {\n    if (grid[y][x].isDone) {\n      alert(\"you need to unlock pipe to rotate it\");\n      return;\n    }\n    setCounter(counter + 1);\n    const newGrid = [...grid];\n    grid[y][x] = rotatePipe(newGrid[y][x]);\n    setHistory(appendRotateMessage(history, x, y));\n    setVerifyMsg(\"\");\n    setGrid(newGrid);\n  };\n\n  const rightClickHandler = (\n    e: React.MouseEvent<HTMLDivElement, MouseEvent>,\n    x: number,\n    y: number\n  ) => {\n    e.preventDefault();\n    const newGrid = [...grid];\n    if (newGrid[y][x].isDone) {\n      newGrid[y][x].isDone = false;\n      setGrid(newGrid);\n      return;\n    }\n    newGrid[y][x].allowedPositions = [newGrid[y][x].position];\n    newGrid[y][x].isDone = true;\n    setGrid(newGrid);\n  };\n\n  const verifyResults = () => {\n    client.send(history);\n    client.send(\"verify\");\n    setHistory(\"rotate\");\n  };\n\n  return (\n    <div>\n      <Heading />\n      <div className='container container-fluid main-content'>\n        <div className='row'>\n          <div className='col-sm-9 col-xs-12'>\n            <Options\n              whatRender={whatRender}\n              levels={levels}\n              onLevelClick={setLevel}\n              onStartClick={startGame}\n              onAutoSolveClick={startAutoSolve}\n              onStopAutoSolveClick={stopAutoSolve}\n              onRestartClick={restartGame}\n            />\n            {currentLevel.current < 3 && whatRender.fancyGrid && (\n              <Slider\n                min={0}\n                max={4}\n                value={autoSolveTime}\n                onChange={(value) => {\n                  setAutoSolveTime(value);\n                }}\n              />\n            )}\n            <FancyGrid\n              whatRender={whatRender}\n              grid={grid}\n              cellWidth={cellWidth}\n              xx={xx.current}\n              yy={yy.current}\n              level={currentLevel.current}\n              cellClickHandler={cellClickHandler}\n              rightClickHandler={rightClickHandler}\n            />\n            <SimpleGrid\n              handleGridShow={() =>\n                setWhatRender({\n                  ...whatRender,\n                  simpleGrid: true,\n                })\n              }\n              rightClickHandler={rightClickHandler}\n              whatRender={whatRender}\n              cellClickHandler={cellClickHandler}\n              grid={grid}\n              level={currentLevel.current}\n            />\n          </div>\n          <div className='col-sm-3 col-xs-12 center-xs'>\n            <History\n              whatRender={whatRender}\n              history={history}\n              counter={counter}\n              verifyMsg={verifyMsg}\n              level={currentLevel.current}\n              onVerifyClick={verifyResults}\n            />\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","E:\\New folder\\pipes-task\\pipes-task\\src\\engine.ts",["67"],"export interface Pipe {\r\n  name: ShapeName;\r\n  top: boolean;\r\n  right: boolean;\r\n  bottom: boolean;\r\n  left: boolean;\r\n  isDone: boolean;\r\n  allowedPositions: Position[];\r\n  position: Position;\r\n}\r\n\r\nexport type Position = 0 | 90 | 180 | 270;\r\n\r\nexport type Direction = \"top\" | \"right\" | \"bottom\" | \"left\";\r\n\r\nexport type ShapeType =\r\n  | \"┏\"\r\n  | \"┓\"\r\n  | \"┗\"\r\n  | \"┛\"\r\n  | \"╸\"\r\n  | \"╺\"\r\n  | \"╹\"\r\n  | \"╻\"\r\n  | \"┣\"\r\n  | \"┳\"\r\n  | \"┻\"\r\n  | \"┫\"\r\n  | \"━\"\r\n  | \"┃\"\r\n  | \"╋\";\r\n\r\ntype ShapeName = \"Line\" | \"Elbow\" | \"Tee\" | \"End\" | \"Cross\" ;\r\n\r\ninterface Output  {\r\n  rotateMessage: string , pipesLeft: number\r\n}\r\n\r\nexport const splitRawDataInShapeRows = (\r\n  mapAsString: string,\r\n): string[] => {\r\n  const legitMapData = mapAsString.split(\"\\n\");\r\n    legitMapData.shift();\r\n    legitMapData.pop();\r\n  return legitMapData;\r\n};\r\n\r\nexport const makeShapeGridFromRows = (rows: string[]): ShapeType[][] => {\r\n  const output: ShapeType[][] = rows.map((row) => {\r\n    return row.split(\"\") as ShapeType[];\r\n  });\r\n  return output;\r\n};\r\n\r\nexport const initNewPipe = (\r\n  name: ShapeName,\r\n  top: boolean,\r\n  right: boolean,\r\n  bottom: boolean,\r\n  left: boolean,\r\n  position: Position,\r\n): Pipe => {\r\n  return {\r\n    name,\r\n    top,\r\n    right,\r\n    bottom,\r\n    left,\r\n    position,\r\n    isDone: name === \"Cross\" ? true : false,\r\n    allowedPositions: name === \"Cross\" ? [0] : [0, 90, 180, 270],\r\n  };\r\n};\r\n\r\nexport const translateFromShapeToPipe = (\r\n  shape: ShapeType\r\n): Pipe => {\r\n  switch (shape) {\r\n    case \"┗\": {\r\n      return initNewPipe(\"Elbow\", true, true, false, false, 0);\r\n    }\r\n    case \"┏\": {\r\n      return initNewPipe(\"Elbow\", false, true, true, false, 90);\r\n    }\r\n    case \"┓\": {\r\n      return initNewPipe(\"Elbow\", false, false, true, true, 180);\r\n    }\r\n    case \"┛\": {\r\n      return initNewPipe(\"Elbow\", true, false, false, true, 270);\r\n    }\r\n    case \"╸\": {\r\n      return initNewPipe(\"End\", false, false, false, true, 270);\r\n    }\r\n    case \"╹\": {\r\n      return initNewPipe(\"End\", true, false, false, false, 0);\r\n    }\r\n    case \"╻\": {\r\n      return initNewPipe(\"End\", false, false, true, false, 180);\r\n    }\r\n    case \"╺\": {\r\n      return initNewPipe(\"End\", false, true, false, false, 90);\r\n    }\r\n    case \"┣\": {\r\n      return initNewPipe(\"Tee\", true, true, true, false, 90);\r\n    }\r\n    case \"┳\": {\r\n      return initNewPipe(\"Tee\", false, true, true, true, 180);\r\n    }\r\n    case \"┻\": {\r\n      return initNewPipe(\"Tee\", true, true, false, true, 0);\r\n    }\r\n    case \"┫\": {\r\n      return initNewPipe(\"Tee\", true, false, true, true, 270);\r\n    }\r\n    case \"━\": {\r\n      return initNewPipe(\"Line\", false, true, false, true, 90);\r\n    }\r\n    case \"┃\": {\r\n      return initNewPipe(\"Line\", true, false, true, false, 0);\r\n    }\r\n    case \"╋\": {\r\n      return initNewPipe(\"Cross\", true, true, true, true, 0);\r\n    }\r\n    default: {\r\n      return initNewPipe(\"Cross\", false, false, false, false, 0);\r\n    }\r\n  }\r\n};\r\nexport const translateFromPipeToShape = (pipe: Pipe): ShapeType => {\r\n  const { top, right, bottom, left } = pipe;\r\n  const pipePositions = [top, right, bottom, left];\r\n  switch (JSON.stringify(pipePositions)) {\r\n    case JSON.stringify([false, true, true, false]):\r\n      return \"┏\";\r\n    case JSON.stringify([false, false, true, true]):\r\n      return \"┓\";\r\n    case JSON.stringify([true, false, false, true]):\r\n      return \"┛\";\r\n    case JSON.stringify([true, true, false, false]):\r\n      return \"┗\";\r\n    case JSON.stringify([true, false, true, false]):\r\n      return \"┃\";\r\n    case JSON.stringify([false, true, false, true]):\r\n      return \"━\";\r\n    case JSON.stringify([true, false, true, true]):\r\n      return \"┫\";\r\n    case JSON.stringify([true, true, true, false]):\r\n      return \"┣\";\r\n    case JSON.stringify([true, true, false, true]):\r\n      return \"┻\";\r\n    case JSON.stringify([false, true, true, true]):\r\n      return \"┳\";\r\n    case JSON.stringify([false, false, false, true]):\r\n      return \"╸\";\r\n    case JSON.stringify([false, false, true, false]):\r\n      return \"╻\";\r\n    case JSON.stringify([false, true, false, false]):\r\n      return \"╺\";\r\n    case JSON.stringify([true, false, false, false]):\r\n      return \"╹\";\r\n    default:\r\n      return \"╋\";\r\n  }\r\n};\r\n\r\nexport const transformShapeGridToPipeGrid = (\r\n  shapeGrid: ShapeType[][]\r\n): Pipe[][] => {\r\n  const output = shapeGrid.map((row) => {\r\n    return row.map((shape) => {\r\n      return translateFromShapeToPipe(shape);\r\n    });\r\n  });\r\n  return output;\r\n};\r\n\r\nexport const rotatePipe = (pipe: Pipe): Pipe => {\r\n  const output = { ...pipe };\r\n  output.top = pipe.left;\r\n  output.left = pipe.bottom;\r\n  output.bottom = pipe.right;\r\n  output.right = pipe.top;\r\n  if (output.position > 200) {\r\n    output.position = 0;\r\n  } else {\r\n    output.position += 90;\r\n  }\r\n  return output;\r\n};\r\n\r\nexport const appendRotateMessage = (\r\n  base: string,\r\n  x: number,\r\n  y: number\r\n): string => {\r\n  if (base.length > 8) {\r\n    return (base += `\\n${x} ${y}`);\r\n  }\r\n  return (base += ` ${x} ${y}`);\r\n};\r\n\r\nexport const calculateRotationCount = (\r\n  positionNow: Position,\r\n  desiredPosition: Position\r\n): number => {\r\n  let output = 0;\r\n  let tmp = positionNow;\r\n  while (tmp !== desiredPosition) {\r\n    output += 1;\r\n    if (tmp > 200) {\r\n      tmp = 0;\r\n    } else {\r\n      tmp += 90;\r\n    }\r\n  }\r\n  return output;\r\n};\r\n\r\n// Check if pipe must be NOT connected given direction even if it's not done\r\nexport const mustBeNotConnected = (\r\n  x: number,\r\n  y: number,\r\n  direction: Direction,\r\n  grid: Pipe[][]\r\n): boolean => {\r\n  const pipe = grid[y][x];\r\n  // if all pipes posotions possible, then it's not certain and return false\r\n  if (pipe.allowedPositions.length > 3) return false;\r\n\r\n  let output = true;\r\n  const positionNow = pipe.position;\r\n  pipe.allowedPositions.forEach((posAllowed) => {\r\n    const count = calculateRotationCount(positionNow, posAllowed);\r\n    let tmpPipe = { ...pipe };\r\n    for (let i = 0; i < count; i++) {\r\n      tmpPipe = rotatePipe(tmpPipe);\r\n    }\r\n    if (tmpPipe[direction]) output = false;\r\n  });\r\n  return output;\r\n};\r\n\r\n// Check if pipe must be connected given direction even if it's not done\r\nexport const mustBeConnected = (\r\n  x: number,\r\n  y: number,\r\n  direction: Direction,\r\n  grid: Pipe[][]\r\n): boolean => {\r\n  const pipe = grid[y][x];\r\n\r\n  if (pipe.allowedPositions.length > 3) return false;\r\n\r\n  let output = true;\r\n  const positionNow = pipe.position;\r\n  pipe.allowedPositions.forEach((posAllowed) => {\r\n    const count = calculateRotationCount(positionNow, posAllowed);\r\n    let tmpPipe = { ...pipe };\r\n    for (let i = 0; i < count; i++) {\r\n      tmpPipe = rotatePipe(tmpPipe);\r\n    }\r\n    if (!tmpPipe[direction]) output = false;\r\n  });\r\n\r\n  return output;\r\n};\r\n\r\n// Removes given positions from positions array and returns updated positions array\r\nexport const spliceOutPositions = (\r\n  allowdPositons: Position[],\r\n  ...positionsToRemove: Position[]\r\n): Position[] => {\r\n  const output = [...allowdPositons];\r\n  positionsToRemove.forEach((pos) => {\r\n    const idx = output.indexOf(pos);\r\n    if (idx > -1) output.splice(idx, 1);\r\n  });\r\n  return output;\r\n};\r\n\r\n// --------------- CHECK LINE SHAPE -------------\r\n\r\nexport const checkLeft_Line = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const leftPipe = grid[y][x - 1];\r\n  // If there is no pipe on the left, reduce to single possible position\r\n  if (!leftPipe) return [0];\r\n  // If left pipe does not allow right connection, reduce to single possible position\r\n  if (mustBeNotConnected(x - 1, y, \"right\", grid)) return [0];\r\n  // If left pipe must have right connection, reduce to single possible position\r\n  if (mustBeConnected(x - 1, y, \"right\", grid)) return [90];\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkRight_Line = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const rightPipe = grid[y][x + 1];\r\n  if (!rightPipe) return [0];\r\n  if (mustBeConnected(x + 1, y, \"left\", grid)) return [90];\r\n  if (mustBeNotConnected(x + 1, y, \"left\", grid)) return [0];\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkTop_Line = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y - 1 < 0) return [90];\r\n  if (mustBeConnected(x, y - 1, \"bottom\", grid)) return [0];\r\n  if (mustBeNotConnected(x, y - 1, \"bottom\", grid)) return [90];\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkBottom_Line = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y + 1 >= grid.length) return [90];\r\n  if (mustBeConnected(x, y + 1, \"top\", grid)) return [0];\r\n  if (mustBeNotConnected(x, y + 1, \"top\", grid)) return [90];\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\n// --------------- CHECK TEE SHAPE -------------\r\n\r\nexport const checkLeft_Tee = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const leftPipe = grid[y][x - 1];\r\n  // If there is no pipe on the left, reduce to single possible position\r\n  if (!leftPipe) return [90];\r\n  // If left pipe does not allow right connection, reduce to single possible position\r\n  if (mustBeNotConnected(x - 1, y, \"right\", grid)) return [90];\r\n  // If left pipe must have right connection, slice out one not possible connection\r\n  if (mustBeConnected(x - 1, y, \"right\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkRight_Tee = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const rightPipe = grid[y][x + 1];\r\n  if (!rightPipe) return [270];\r\n  if (mustBeNotConnected(x + 1, y, \"left\", grid)) return [270];\r\n  if (mustBeConnected(x + 1, y, \"left\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 270);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkTop_Tee = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y - 1 < 0) return [180];\r\n  if (mustBeNotConnected(x, y - 1, \"bottom\", grid)) return [180];\r\n  if (mustBeConnected(x, y - 1, \"bottom\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkBottom_Tee = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y + 1 >= grid.length) return [0];\r\n  if (mustBeNotConnected(x, y + 1, \"top\", grid)) return [0];\r\n  if (mustBeConnected(x, y + 1, \"top\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\n// --------------- CHECK END SHAPE -------------\r\n\r\nexport const checkLeft_End = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const leftPipe = grid[y][x - 1];\r\n  // If there is no pipe on the left, slice out one not possible position\r\n  if (!leftPipe) return spliceOutPositions(grid[y][x].allowedPositions, 270);\r\n  // If left pipe must NOT be connected to right, slice out one not possible position\r\n  if (mustBeNotConnected(x - 1, y, \"right\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 270);\r\n  // If left pipe must be connected to right, reduce to one possible connection\r\n  if (mustBeConnected(x - 1, y, \"right\", grid)) return [270];\r\n  // If left pipe is End too, slice out one not possible direction\r\n  else if (leftPipe.name === \"End\")\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 270);\r\n  // if no pattern found\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkRight_End = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const rightPipe = grid[y][x + 1];\r\n  if (!rightPipe) return spliceOutPositions(grid[y][x].allowedPositions, 90);\r\n  if (mustBeNotConnected(x + 1, y, \"left\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90);\r\n  if (mustBeConnected(x + 1, y, \"left\", grid)) return [90];\r\n  else if (rightPipe.name === \"End\")\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkTop_End = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y - 1 < 0) return spliceOutPositions(grid[y][x].allowedPositions, 0);\r\n  if (mustBeNotConnected(x, y - 1, \"bottom\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0);\r\n  if (mustBeConnected(x, y - 1, \"bottom\", grid)) return [0];\r\n  else if (grid[y - 1][x].name === \"End\")\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkBottom_End = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y + 1 >= grid.length)\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180);\r\n  if (mustBeNotConnected(x, y + 1, \"top\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180);\r\n  if (mustBeConnected(x, y + 1, \"top\", grid)) return [180];\r\n  else if (grid[y + 1][x].name === \"End\")\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\n// --------------- CHECK ELBOW SHAPE -------------\r\n\r\nexport const checkLeft_Elbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const leftPipe = grid[y][x - 1];\r\n  // If there is no pipe on the left, slice out two not possible positions\r\n  if (!leftPipe)\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180, 270);\r\n  // If left pipe cant have right connection, slice out two not possible positions\r\n  if (mustBeNotConnected(x - 1, y, \"right\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180, 270);\r\n  // If left pipe must have right connection, slice out two not possible positions\r\n  if (mustBeConnected(x - 1, y, \"right\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0, 90);\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkRight_Elbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const rightPipe = grid[y][x + 1];\r\n  if (!rightPipe) return spliceOutPositions(grid[y][x].allowedPositions, 0, 90);\r\n  if (mustBeNotConnected(x + 1, y, \"left\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0, 90);\r\n  if (mustBeConnected(x + 1, y, \"left\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180, 270);\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkTop_Elbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y - 1 < 0) return spliceOutPositions(grid[y][x].allowedPositions, 0, 270);\r\n  if (mustBeNotConnected(x, y - 1, \"bottom\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0, 270);\r\n  if (mustBeConnected(x, y - 1, \"bottom\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90, 180);\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkBottom_Elbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y + 1 >= grid.length)\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90, 180);\r\n  if (mustBeNotConnected(x, y + 1, \"top\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90, 180);\r\n  if (mustBeConnected(x, y + 1, \"top\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0, 270);\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\n\r\nexport const solvePipe = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][],\r\n  rotateMsg: string,\r\n  pipesToSolve: number\r\n\r\n): Output => {\r\n  let output = rotateMsg;\r\n  let pipesLeft = pipesToSolve;\r\n\r\n  \r\n  const count = calculateRotationCount(\r\n    grid[y][x].position,\r\n    grid[y][x].allowedPositions[0]\r\n  );\r\n  for (let i = 0; i < count; i++) {\r\n    grid[y][x] = rotatePipe(grid[y][x]);\r\n    // message @ end\r\n    output = appendRotateMessage(output, x, y);\r\n  }\r\n  grid[y][x].isDone = true;\r\n  pipesLeft -=1;\r\n  \r\n  const outputObj = {rotateMessage: output , pipesLeft}\r\n  return outputObj\r\n};\r\n\r\n\r\nconst isDoneAndConnectedSpecificDirection = (\r\n  x: number,\r\n  y: number,\r\n  direction: Direction,\r\n  grid: Pipe[][]\r\n) => {\r\n  // If passed not legit coordinates\r\n  if (x < 0 || y < 0 || x >= grid[0].length || y >= grid.length) return false;\r\n  // If pipe is not done\r\n  if (!grid[y][x].isDone) return false;\r\n  // if pipe is connected given direction\r\n  if (grid[y][x][direction]) return true;\r\n  // else false\r\n  return false;\r\n};\r\n\r\nconst checkLine = (x: number, y: number, grid: Pipe[][], rotateMsg: string, pipesToSolve:number):Output => {\r\n  let output = rotateMsg;\r\n  grid[y][x].allowedPositions = checkLeft_Line(x, y, grid);\r\n  grid[y][x].allowedPositions = checkRight_Line(x, y, grid);\r\n  grid[y][x].allowedPositions = checkTop_Line(x, y, grid);\r\n  grid[y][x].allowedPositions = checkBottom_Line(x, y, grid);\r\n  if (grid[y][x].allowedPositions.length === 1) {\r\n     return  solvePipe(x, y, grid, output, pipesToSolve);\r\n  }\r\n  const outputObj =  {rotateMessage: output , pipesLeft: pipesToSolve}\r\n  return outputObj\r\n};\r\n\r\nconst checkTee = (x: number, y: number, grid: Pipe[][], rotateMsg: string, pipesToSolve:number):Output => {\r\n  let output = rotateMsg;\r\n  grid[y][x].allowedPositions = checkLeft_Tee(x, y, grid);\r\n  grid[y][x].allowedPositions = checkRight_Tee(x, y, grid);\r\n  grid[y][x].allowedPositions = checkTop_Tee(x, y, grid);\r\n  grid[y][x].allowedPositions = checkBottom_Tee(x, y, grid);\r\n  if (grid[y][x].allowedPositions.length === 1) {\r\n     return  solvePipe(x, y, grid, output, pipesToSolve);\r\n  }\r\n  const outputObj =  {rotateMessage: output , pipesLeft: pipesToSolve}\r\n  return outputObj\r\n};\r\n\r\nconst checkEnd = (x: number, y: number, grid: Pipe[][], rotateMsg: string, pipesToSolve:number) => {\r\n  let output = rotateMsg;\r\n  grid[y][x].allowedPositions = checkLeft_End(x, y, grid);\r\n  grid[y][x].allowedPositions = checkRight_End(x, y, grid);\r\n  grid[y][x].allowedPositions = checkTop_End(x, y, grid);\r\n  grid[y][x].allowedPositions = checkBottom_End(x, y, grid);\r\n  if (grid[y][x].allowedPositions.length === 1) {\r\n     return  solvePipe(x, y, grid, output, pipesToSolve);\r\n  }\r\n  const outputObj =  {rotateMessage: output , pipesLeft: pipesToSolve}\r\n  return outputObj\r\n};\r\n\r\nconst checkElbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][],\r\n  rotateMsg: string, \r\n  pipesToSolve:number\r\n) => {\r\n  let output = rotateMsg;\r\n  grid[y][x].allowedPositions = checkLeft_Elbow(x, y, grid);\r\n  grid[y][x].allowedPositions = checkRight_Elbow(x, y, grid);\r\n  grid[y][x].allowedPositions = checkTop_Elbow(x, y, grid);\r\n  grid[y][x].allowedPositions = checkBottom_Elbow(x, y, grid);\r\n  if (grid[y][x].allowedPositions.length === 1) {\r\n    return  solvePipe(x, y, grid, output, pipesToSolve);\r\n  }\r\n  const outputObj =  {rotateMessage: output , pipesLeft: pipesToSolve}\r\n  return outputObj\r\n};\r\n\r\nexport const checkPipe = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][],\r\n  rotateMsg: string,\r\n  pipesToSolve : number\r\n): {rotateMessage : string, pipesLeft : number} => {\r\n  switch (grid[y][x].name) {\r\n    case \"Line\": {\r\n      return checkLine(x, y, grid, rotateMsg, pipesToSolve);\r\n    }\r\n    case \"Tee\": {\r\n      return checkTee(x, y, grid, rotateMsg, pipesToSolve);\r\n    }\r\n    case \"End\": {\r\n      return checkEnd(x, y, grid, rotateMsg, pipesToSolve);\r\n    }\r\n    case \"Elbow\": {\r\n      return checkElbow(x, y, grid, rotateMsg, pipesToSolve);\r\n    }\r\n    default: {\r\n      const outputObj =  {rotateMessage: rotateMsg , pipesLeft: pipesToSolve}\r\n      return outputObj\r\n    }\r\n  }\r\n};\r\n","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\options\\Options.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\header\\Header.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\rules\\Rules.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\history\\History.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\cell\\Cell.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\fancyGrid\\FancyGrid.tsx",["68"],"import React, { FC } from \"react\";\nimport { WhatRender } from \"../../App\";\nimport { Pipe } from \"../../engine\";\nimport { Cell } from \"../cell/Cell\";\nimport Slider from \"../slider/Slider\";\nimport Spinner from \"../spinner/Spinner\";\nimport style from \"./fancyGrid.module.scss\";\n\ntype Props = {\n  grid: Pipe[][];\n  cellWidth: string;\n  xx: number;\n  yy: number;\n  level: number;\n  whatRender: WhatRender;\n  cellClickHandler: (x: number, y: number, pipe: Pipe) => void;\n  rightClickHandler: (\n    e: React.MouseEvent<HTMLDivElement, MouseEvent>,\n    x: number,\n    y: number\n  ) => void;\n};\n\nconst FancyGrid: FC<Props> = ({\n  grid,\n  cellWidth,\n  xx,\n  yy,\n  level,\n  whatRender,\n  cellClickHandler,\n  rightClickHandler,\n}) => {\n  const { fancyGrid, stopSolveBtn } = whatRender;\n\n  const showFancyGrid = () => {\n    if (fancyGrid && level > 2 && stopSolveBtn) {\n      return false;\n    }\n    if (fancyGrid) {\n      return true;\n    }\n    return false;\n  };\n  return (\n    <div className={style.fancyGrid}>\n      {fancyGrid && level > 2 && stopSolveBtn && <Spinner />}\n      {showFancyGrid() &&\n        grid.map((row, y) => {\n          return (\n            <div className={style.grid} key={`key${y}`}>\n              {row.map((pipe, x) => {\n                return (\n                  <div\n                    key={`key${y}${x}`}\n                    style={{ width: cellWidth, minWidth: \"30px\" }}\n                  >\n                    <Cell\n                      pipe={pipe}\n                      isActive={xx === x && yy === y}\n                      onClick={() => cellClickHandler(x, y, pipe)}\n                      onRightClick={(\n                        e: React.MouseEvent<HTMLDivElement, MouseEvent>\n                      ) => rightClickHandler(e, x, y)}\n                    />\n                  </div>\n                );\n              })}\n            </div>\n          );\n        })}\n    </div>\n  );\n};\n\nexport default FancyGrid;\n","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\simpleGrid\\SimpleGrid.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\spinner\\Spinner.tsx",[],["69","70"],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\slider\\Slider.tsx",["71"],"import React, { FC, useState } from \"react\";\nimport style from \"./slider.module.scss\";\n\ntype Props = {\n  min: number;\n  max: number;\n  value: number;\n  onChange: (value: number) => void;\n};\n\nconst Slider: FC<Props> = ({ min = 0, max = 4, value, onChange }) => {\n  return (\n    <div className='row'>\n      <div className='col-xs-2 end-xs col-xs-offset-1'>slower</div>\n      <div className='col-xs-6'>\n        <div className={style.slider}>\n          <input\n            className={style.range}\n            type='range'\n            min={min}\n            max={max}\n            value={value}\n            onChange={(e) => onChange(parseInt(e.target.value, 10))}\n          />\n        </div>\n      </div>\n      <div className='col-xs-2 start-xs'>faster</div>\n    </div>\n  );\n};\n\nexport default Slider;\n","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\button\\Button.tsx",[],{"ruleId":"72","replacedBy":"73"},{"ruleId":"74","replacedBy":"75"},{"ruleId":"76","severity":1,"message":"77","line":131,"column":6,"nodeType":"78","endLine":131,"endColumn":26,"suggestions":"79"},{"ruleId":"80","severity":1,"message":"81","line":549,"column":7,"nodeType":"82","messageId":"83","endLine":549,"endColumn":42},{"ruleId":"80","severity":1,"message":"84","line":5,"column":8,"nodeType":"82","messageId":"83","endLine":5,"endColumn":14},{"ruleId":"72","replacedBy":"85"},{"ruleId":"74","replacedBy":"86"},{"ruleId":"80","severity":1,"message":"87","line":1,"column":21,"nodeType":"82","messageId":"83","endLine":1,"endColumn":29},"no-native-reassign",["88"],"no-negated-in-lhs",["89"],"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'autoSolveTime', 'grid', 'history', and 'stopAutoSolve'. Either include them or remove the dependency array.","ArrayExpression",["90"],"@typescript-eslint/no-unused-vars","'isDoneAndConnectedSpecificDirection' is assigned a value but never used.","Identifier","unusedVar","'Slider' is defined but never used.",["88"],["89"],"'useState' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"91","fix":"92"},"Update the dependencies array to be: [counter, autoSolve, grid, autoSolveTime, history, stopAutoSolve]",{"range":"93","text":"94"},[3575,3595],"[counter, autoSolve, grid, autoSolveTime, history, stopAutoSolve]"]
[{"E:\\New folder\\pipes-task\\pipes-task\\src\\index.tsx":"1","E:\\New folder\\pipes-task\\pipes-task\\src\\reportWebVitals.ts":"2","E:\\New folder\\pipes-task\\pipes-task\\src\\App.tsx":"3","E:\\New folder\\pipes-task\\pipes-task\\src\\engine.ts":"4","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\options\\Options.tsx":"5","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\header\\Header.tsx":"6","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\rules\\Rules.tsx":"7","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\cell\\Cell.tsx":"8","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\fancyGrid\\FancyGrid.tsx":"9","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\simpleGrid\\SimpleGrid.tsx":"10","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\spinner\\Spinner.tsx":"11","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\slider\\Slider.tsx":"12","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\button\\Button.tsx":"13","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\resultsTable\\ResultsTable.tsx":"14","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\verify\\Verify.tsx":"15"},{"size":296,"mtime":1614208786438,"results":"16","hashOfConfig":"17"},{"size":425,"mtime":499158900000,"results":"18","hashOfConfig":"17"},{"size":9057,"mtime":1614454506802,"results":"19","hashOfConfig":"17"},{"size":19461,"mtime":1614433896643,"results":"20","hashOfConfig":"17"},{"size":2073,"mtime":1614452838760,"results":"21","hashOfConfig":"17"},{"size":1123,"mtime":1614425837163,"results":"22","hashOfConfig":"17"},{"size":1430,"mtime":1614433002786,"results":"23","hashOfConfig":"17"},{"size":1059,"mtime":1614274290679,"results":"24","hashOfConfig":"17"},{"size":1930,"mtime":1614428123290,"results":"25","hashOfConfig":"17"},{"size":2109,"mtime":1614433928580,"results":"26","hashOfConfig":"17"},{"size":558,"mtime":1614336097575,"results":"27","hashOfConfig":"17"},{"size":794,"mtime":1614431873439,"results":"28","hashOfConfig":"17"},{"size":699,"mtime":1614266727175,"results":"29","hashOfConfig":"17"},{"size":1558,"mtime":1614450799355,"results":"30","hashOfConfig":"17"},{"size":1582,"mtime":1614451206115,"results":"31","hashOfConfig":"17"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},"1ctwnvw",{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"39","messages":"40","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41","usedDeprecatedRules":"34"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"34"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59","usedDeprecatedRules":"34"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64","usedDeprecatedRules":"34"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},"E:\\New folder\\pipes-task\\pipes-task\\src\\index.tsx",[],["67","68"],"E:\\New folder\\pipes-task\\pipes-task\\src\\reportWebVitals.ts",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\App.tsx",["69","70"],"E:\\New folder\\pipes-task\\pipes-task\\src\\engine.ts",["71"],"export interface Pipe {\r\n  name: ShapeName;\r\n  top: boolean;\r\n  right: boolean;\r\n  bottom: boolean;\r\n  left: boolean;\r\n  isDone: boolean;\r\n  allowedPositions: Position[];\r\n  position: Position;\r\n}\r\n\r\nexport type Position = 0 | 90 | 180 | 270;\r\n\r\nexport type Direction = \"top\" | \"right\" | \"bottom\" | \"left\";\r\n\r\nexport type ShapeType =\r\n  | \"┏\"\r\n  | \"┓\"\r\n  | \"┗\"\r\n  | \"┛\"\r\n  | \"╸\"\r\n  | \"╺\"\r\n  | \"╹\"\r\n  | \"╻\"\r\n  | \"┣\"\r\n  | \"┳\"\r\n  | \"┻\"\r\n  | \"┫\"\r\n  | \"━\"\r\n  | \"┃\"\r\n  | \"╋\";\r\n\r\ntype ShapeName = \"Line\" | \"Elbow\" | \"Tee\" | \"End\" | \"Cross\" ;\r\n\r\ninterface Output  {\r\n  rotateMessage: string , pipesLeft: number\r\n}\r\n\r\nexport const splitRawDataInShapeRows = (\r\n  mapAsString: string,\r\n): string[] => {\r\n  const legitMapData = mapAsString.split(\"\\n\");\r\n    legitMapData.shift();\r\n    legitMapData.pop();\r\n  return legitMapData;\r\n};\r\n\r\nexport const makeShapeGridFromRows = (rows: string[]): ShapeType[][] => {\r\n  const output: ShapeType[][] = rows.map((row) => {\r\n    return row.split(\"\") as ShapeType[];\r\n  });\r\n  return output;\r\n};\r\n\r\nexport const initNewPipe = (\r\n  name: ShapeName,\r\n  top: boolean,\r\n  right: boolean,\r\n  bottom: boolean,\r\n  left: boolean,\r\n  position: Position,\r\n): Pipe => {\r\n  return {\r\n    name,\r\n    top,\r\n    right,\r\n    bottom,\r\n    left,\r\n    position,\r\n    isDone: name === \"Cross\" ? true : false,\r\n    allowedPositions: name === \"Cross\" ? [0] : [0, 90, 180, 270],\r\n  };\r\n};\r\n\r\nexport const translateFromShapeToPipe = (\r\n  shape: ShapeType\r\n): Pipe => {\r\n  switch (shape) {\r\n    case \"┗\": {\r\n      return initNewPipe(\"Elbow\", true, true, false, false, 0);\r\n    }\r\n    case \"┏\": {\r\n      return initNewPipe(\"Elbow\", false, true, true, false, 90);\r\n    }\r\n    case \"┓\": {\r\n      return initNewPipe(\"Elbow\", false, false, true, true, 180);\r\n    }\r\n    case \"┛\": {\r\n      return initNewPipe(\"Elbow\", true, false, false, true, 270);\r\n    }\r\n    case \"╸\": {\r\n      return initNewPipe(\"End\", false, false, false, true, 270);\r\n    }\r\n    case \"╹\": {\r\n      return initNewPipe(\"End\", true, false, false, false, 0);\r\n    }\r\n    case \"╻\": {\r\n      return initNewPipe(\"End\", false, false, true, false, 180);\r\n    }\r\n    case \"╺\": {\r\n      return initNewPipe(\"End\", false, true, false, false, 90);\r\n    }\r\n    case \"┣\": {\r\n      return initNewPipe(\"Tee\", true, true, true, false, 90);\r\n    }\r\n    case \"┳\": {\r\n      return initNewPipe(\"Tee\", false, true, true, true, 180);\r\n    }\r\n    case \"┻\": {\r\n      return initNewPipe(\"Tee\", true, true, false, true, 0);\r\n    }\r\n    case \"┫\": {\r\n      return initNewPipe(\"Tee\", true, false, true, true, 270);\r\n    }\r\n    case \"━\": {\r\n      return initNewPipe(\"Line\", false, true, false, true, 90);\r\n    }\r\n    case \"┃\": {\r\n      return initNewPipe(\"Line\", true, false, true, false, 0);\r\n    }\r\n    case \"╋\": {\r\n      return initNewPipe(\"Cross\", true, true, true, true, 0);\r\n    }\r\n    default: {\r\n      return initNewPipe(\"Cross\", false, false, false, false, 0);\r\n    }\r\n  }\r\n};\r\nexport const translateFromPipeToShape = (pipe: Pipe): ShapeType => {\r\n  const { top, right, bottom, left } = pipe;\r\n  const pipePositions = [top, right, bottom, left];\r\n  switch (JSON.stringify(pipePositions)) {\r\n    case JSON.stringify([false, true, true, false]):\r\n      return \"┏\";\r\n    case JSON.stringify([false, false, true, true]):\r\n      return \"┓\";\r\n    case JSON.stringify([true, false, false, true]):\r\n      return \"┛\";\r\n    case JSON.stringify([true, true, false, false]):\r\n      return \"┗\";\r\n    case JSON.stringify([true, false, true, false]):\r\n      return \"┃\";\r\n    case JSON.stringify([false, true, false, true]):\r\n      return \"━\";\r\n    case JSON.stringify([true, false, true, true]):\r\n      return \"┫\";\r\n    case JSON.stringify([true, true, true, false]):\r\n      return \"┣\";\r\n    case JSON.stringify([true, true, false, true]):\r\n      return \"┻\";\r\n    case JSON.stringify([false, true, true, true]):\r\n      return \"┳\";\r\n    case JSON.stringify([false, false, false, true]):\r\n      return \"╸\";\r\n    case JSON.stringify([false, false, true, false]):\r\n      return \"╻\";\r\n    case JSON.stringify([false, true, false, false]):\r\n      return \"╺\";\r\n    case JSON.stringify([true, false, false, false]):\r\n      return \"╹\";\r\n    default:\r\n      return \"╋\";\r\n  }\r\n};\r\n\r\nexport const transformShapeGridToPipeGrid = (\r\n  shapeGrid: ShapeType[][]\r\n): Pipe[][] => {\r\n  const output = shapeGrid.map((row) => {\r\n    return row.map((shape) => {\r\n      return translateFromShapeToPipe(shape);\r\n    });\r\n  });\r\n  return output;\r\n};\r\n\r\nexport const rotatePipe = (pipe: Pipe): Pipe => {\r\n  const output = { ...pipe };\r\n  output.top = pipe.left;\r\n  output.left = pipe.bottom;\r\n  output.bottom = pipe.right;\r\n  output.right = pipe.top;\r\n  if (output.position > 200) {\r\n    output.position = 0;\r\n  } else {\r\n    output.position += 90;\r\n  }\r\n  return output;\r\n};\r\n\r\nexport const appendRotateMessage = (\r\n  base: string,\r\n  x: number,\r\n  y: number\r\n): string => {\r\n  if (base.length > 8) {\r\n    return (base += `\\n${x} ${y}`);\r\n  }\r\n  return (base += ` ${x} ${y}`);\r\n};\r\n\r\nexport const calculateRotationCount = (\r\n  positionNow: Position,\r\n  desiredPosition: Position\r\n): number => {\r\n  let output = 0;\r\n  let tmp = positionNow;\r\n  while (tmp !== desiredPosition) {\r\n    output += 1;\r\n    if (tmp > 200) {\r\n      tmp = 0;\r\n    } else {\r\n      tmp += 90;\r\n    }\r\n  }\r\n  return output;\r\n};\r\n\r\n// Check if pipe must be NOT connected given direction even if it's not done\r\nexport const mustBeNotConnected = (\r\n  x: number,\r\n  y: number,\r\n  direction: Direction,\r\n  grid: Pipe[][]\r\n): boolean => {\r\n  const pipe = grid[y][x];\r\n  // if all pipes posotions possible, then it's not certain and return false\r\n  if (pipe.allowedPositions.length > 3) return false;\r\n\r\n  let output = true;\r\n  const positionNow = pipe.position;\r\n  pipe.allowedPositions.forEach((posAllowed) => {\r\n    const count = calculateRotationCount(positionNow, posAllowed);\r\n    let tmpPipe = { ...pipe };\r\n    for (let i = 0; i < count; i++) {\r\n      tmpPipe = rotatePipe(tmpPipe);\r\n    }\r\n    if (tmpPipe[direction]) output = false;\r\n  });\r\n  return output;\r\n};\r\n\r\n// Check if pipe must be connected given direction even if it's not done\r\nexport const mustBeConnected = (\r\n  x: number,\r\n  y: number,\r\n  direction: Direction,\r\n  grid: Pipe[][]\r\n): boolean => {\r\n  const pipe = grid[y][x];\r\n\r\n  if (pipe.allowedPositions.length > 3) return false;\r\n\r\n  let output = true;\r\n  const positionNow = pipe.position;\r\n  pipe.allowedPositions.forEach((posAllowed) => {\r\n    const count = calculateRotationCount(positionNow, posAllowed);\r\n    let tmpPipe = { ...pipe };\r\n    for (let i = 0; i < count; i++) {\r\n      tmpPipe = rotatePipe(tmpPipe);\r\n    }\r\n    if (!tmpPipe[direction]) output = false;\r\n  });\r\n\r\n  return output;\r\n};\r\n\r\n// Removes given positions from positions array and returns updated positions array\r\nexport const spliceOutPositions = (\r\n  allowdPositons: Position[],\r\n  ...positionsToRemove: Position[]\r\n): Position[] => {\r\n  const output = [...allowdPositons];\r\n  positionsToRemove.forEach((pos) => {\r\n    const idx = output.indexOf(pos);\r\n    if (idx > -1) output.splice(idx, 1);\r\n  });\r\n  return output;\r\n};\r\n\r\n// --------------- CHECK LINE SHAPE -------------\r\n\r\nexport const checkLeft_Line = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const leftPipe = grid[y][x - 1];\r\n  // If there is no pipe on the left, reduce to single possible position\r\n  if (!leftPipe) return [0];\r\n  // If left pipe does not allow right connection, reduce to single possible position\r\n  if (mustBeNotConnected(x - 1, y, \"right\", grid)) return [0];\r\n  // If left pipe must have right connection, reduce to single possible position\r\n  if (mustBeConnected(x - 1, y, \"right\", grid)) return [90];\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkRight_Line = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const rightPipe = grid[y][x + 1];\r\n  if (!rightPipe) return [0];\r\n  if (mustBeConnected(x + 1, y, \"left\", grid)) return [90];\r\n  if (mustBeNotConnected(x + 1, y, \"left\", grid)) return [0];\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkTop_Line = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y - 1 < 0) return [90];\r\n  if (mustBeConnected(x, y - 1, \"bottom\", grid)) return [0];\r\n  if (mustBeNotConnected(x, y - 1, \"bottom\", grid)) return [90];\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkBottom_Line = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y + 1 >= grid.length) return [90];\r\n  if (mustBeConnected(x, y + 1, \"top\", grid)) return [0];\r\n  if (mustBeNotConnected(x, y + 1, \"top\", grid)) return [90];\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\n// --------------- CHECK TEE SHAPE -------------\r\n\r\nexport const checkLeft_Tee = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const leftPipe = grid[y][x - 1];\r\n  // If there is no pipe on the left, reduce to single possible position\r\n  if (!leftPipe) return [90];\r\n  // If left pipe does not allow right connection, reduce to single possible position\r\n  if (mustBeNotConnected(x - 1, y, \"right\", grid)) return [90];\r\n  // If left pipe must have right connection, slice out one not possible connection\r\n  if (mustBeConnected(x - 1, y, \"right\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkRight_Tee = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const rightPipe = grid[y][x + 1];\r\n  if (!rightPipe) return [270];\r\n  if (mustBeNotConnected(x + 1, y, \"left\", grid)) return [270];\r\n  if (mustBeConnected(x + 1, y, \"left\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 270);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkTop_Tee = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y - 1 < 0) return [180];\r\n  if (mustBeNotConnected(x, y - 1, \"bottom\", grid)) return [180];\r\n  if (mustBeConnected(x, y - 1, \"bottom\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkBottom_Tee = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y + 1 >= grid.length) return [0];\r\n  if (mustBeNotConnected(x, y + 1, \"top\", grid)) return [0];\r\n  if (mustBeConnected(x, y + 1, \"top\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\n// --------------- CHECK END SHAPE -------------\r\n\r\nexport const checkLeft_End = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const leftPipe = grid[y][x - 1];\r\n  // If there is no pipe on the left, slice out one not possible position\r\n  if (!leftPipe) return spliceOutPositions(grid[y][x].allowedPositions, 270);\r\n  // If left pipe must NOT be connected to right, slice out one not possible position\r\n  if (mustBeNotConnected(x - 1, y, \"right\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 270);\r\n  // If left pipe must be connected to right, reduce to one possible connection\r\n  if (mustBeConnected(x - 1, y, \"right\", grid)) return [270];\r\n  // If left pipe is End too, slice out one not possible direction\r\n  else if (leftPipe.name === \"End\")\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 270);\r\n  // if no pattern found\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkRight_End = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const rightPipe = grid[y][x + 1];\r\n  if (!rightPipe) return spliceOutPositions(grid[y][x].allowedPositions, 90);\r\n  if (mustBeNotConnected(x + 1, y, \"left\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90);\r\n  if (mustBeConnected(x + 1, y, \"left\", grid)) return [90];\r\n  else if (rightPipe.name === \"End\")\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkTop_End = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y - 1 < 0) return spliceOutPositions(grid[y][x].allowedPositions, 0);\r\n  if (mustBeNotConnected(x, y - 1, \"bottom\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0);\r\n  if (mustBeConnected(x, y - 1, \"bottom\", grid)) return [0];\r\n  else if (grid[y - 1][x].name === \"End\")\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkBottom_End = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y + 1 >= grid.length)\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180);\r\n  if (mustBeNotConnected(x, y + 1, \"top\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180);\r\n  if (mustBeConnected(x, y + 1, \"top\", grid)) return [180];\r\n  else if (grid[y + 1][x].name === \"End\")\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\n// --------------- CHECK ELBOW SHAPE -------------\r\n\r\nexport const checkLeft_Elbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const leftPipe = grid[y][x - 1];\r\n  // If there is no pipe on the left, slice out two not possible positions\r\n  if (!leftPipe)\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180, 270);\r\n  // If left pipe cant have right connection, slice out two not possible positions\r\n  if (mustBeNotConnected(x - 1, y, \"right\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180, 270);\r\n  // If left pipe must have right connection, slice out two not possible positions\r\n  if (mustBeConnected(x - 1, y, \"right\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0, 90);\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkRight_Elbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const rightPipe = grid[y][x + 1];\r\n  if (!rightPipe) return spliceOutPositions(grid[y][x].allowedPositions, 0, 90);\r\n  if (mustBeNotConnected(x + 1, y, \"left\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0, 90);\r\n  if (mustBeConnected(x + 1, y, \"left\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180, 270);\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkTop_Elbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y - 1 < 0) return spliceOutPositions(grid[y][x].allowedPositions, 0, 270);\r\n  if (mustBeNotConnected(x, y - 1, \"bottom\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0, 270);\r\n  if (mustBeConnected(x, y - 1, \"bottom\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90, 180);\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkBottom_Elbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y + 1 >= grid.length)\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90, 180);\r\n  if (mustBeNotConnected(x, y + 1, \"top\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90, 180);\r\n  if (mustBeConnected(x, y + 1, \"top\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0, 270);\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\n\r\nexport const solvePipe = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][],\r\n  rotateMsg: string,\r\n  pipesToSolve: number\r\n\r\n): Output => {\r\n  let output = rotateMsg;\r\n  let pipesLeft = pipesToSolve;\r\n\r\n  \r\n  const count = calculateRotationCount(\r\n    grid[y][x].position,\r\n    grid[y][x].allowedPositions[0]\r\n  );\r\n  for (let i = 0; i < count; i++) {\r\n    grid[y][x] = rotatePipe(grid[y][x]);\r\n    // message @ end\r\n    output = appendRotateMessage(output, x, y);\r\n  }\r\n  grid[y][x].isDone = true;\r\n  pipesLeft -=1;\r\n  \r\n  const outputObj = {rotateMessage: output , pipesLeft}\r\n  return outputObj\r\n};\r\n\r\n\r\nconst isDoneAndConnectedSpecificDirection = (\r\n  x: number,\r\n  y: number,\r\n  direction: Direction,\r\n  grid: Pipe[][]\r\n) => {\r\n  // If passed not legit coordinates\r\n  if (x < 0 || y < 0 || x >= grid[0].length || y >= grid.length) return false;\r\n  // If pipe is not done\r\n  if (!grid[y][x].isDone) return false;\r\n  // if pipe is connected given direction\r\n  if (grid[y][x][direction]) return true;\r\n  // else false\r\n  return false;\r\n};\r\n\r\nconst checkLine = (x: number, y: number, grid: Pipe[][], rotateMsg: string, pipesToSolve:number):Output => {\r\n  let output = rotateMsg;\r\n  grid[y][x].allowedPositions = checkLeft_Line(x, y, grid);\r\n  grid[y][x].allowedPositions = checkRight_Line(x, y, grid);\r\n  grid[y][x].allowedPositions = checkTop_Line(x, y, grid);\r\n  grid[y][x].allowedPositions = checkBottom_Line(x, y, grid);\r\n  if (grid[y][x].allowedPositions.length === 1) {\r\n     return  solvePipe(x, y, grid, output, pipesToSolve);\r\n  }\r\n  const outputObj =  {rotateMessage: output , pipesLeft: pipesToSolve}\r\n  return outputObj\r\n};\r\n\r\nconst checkTee = (x: number, y: number, grid: Pipe[][], rotateMsg: string, pipesToSolve:number):Output => {\r\n  let output = rotateMsg;\r\n  grid[y][x].allowedPositions = checkLeft_Tee(x, y, grid);\r\n  grid[y][x].allowedPositions = checkRight_Tee(x, y, grid);\r\n  grid[y][x].allowedPositions = checkTop_Tee(x, y, grid);\r\n  grid[y][x].allowedPositions = checkBottom_Tee(x, y, grid);\r\n  if (grid[y][x].allowedPositions.length === 1) {\r\n     return  solvePipe(x, y, grid, output, pipesToSolve);\r\n  }\r\n  const outputObj =  {rotateMessage: output , pipesLeft: pipesToSolve}\r\n  return outputObj\r\n};\r\n\r\nconst checkEnd = (x: number, y: number, grid: Pipe[][], rotateMsg: string, pipesToSolve:number) => {\r\n  let output = rotateMsg;\r\n  grid[y][x].allowedPositions = checkLeft_End(x, y, grid);\r\n  grid[y][x].allowedPositions = checkRight_End(x, y, grid);\r\n  grid[y][x].allowedPositions = checkTop_End(x, y, grid);\r\n  grid[y][x].allowedPositions = checkBottom_End(x, y, grid);\r\n  if (grid[y][x].allowedPositions.length === 1) {\r\n     return  solvePipe(x, y, grid, output, pipesToSolve);\r\n  }\r\n  const outputObj =  {rotateMessage: output , pipesLeft: pipesToSolve}\r\n  return outputObj\r\n};\r\n\r\nconst checkElbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][],\r\n  rotateMsg: string, \r\n  pipesToSolve:number\r\n) => {\r\n  let output = rotateMsg;\r\n  grid[y][x].allowedPositions = checkLeft_Elbow(x, y, grid);\r\n  grid[y][x].allowedPositions = checkRight_Elbow(x, y, grid);\r\n  grid[y][x].allowedPositions = checkTop_Elbow(x, y, grid);\r\n  grid[y][x].allowedPositions = checkBottom_Elbow(x, y, grid);\r\n  if (grid[y][x].allowedPositions.length === 1) {\r\n    return  solvePipe(x, y, grid, output, pipesToSolve);\r\n  }\r\n  const outputObj =  {rotateMessage: output , pipesLeft: pipesToSolve}\r\n  return outputObj\r\n};\r\n\r\nexport const checkPipe = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][],\r\n  rotateMsg: string,\r\n  pipesToSolve : number\r\n): {rotateMessage : string, pipesLeft : number} => {\r\n  switch (grid[y][x].name) {\r\n    case \"Line\": {\r\n      return checkLine(x, y, grid, rotateMsg, pipesToSolve);\r\n    }\r\n    case \"Tee\": {\r\n      return checkTee(x, y, grid, rotateMsg, pipesToSolve);\r\n    }\r\n    case \"End\": {\r\n      return checkEnd(x, y, grid, rotateMsg, pipesToSolve);\r\n    }\r\n    case \"Elbow\": {\r\n      return checkElbow(x, y, grid, rotateMsg, pipesToSolve);\r\n    }\r\n    default: {\r\n      const outputObj =  {rotateMessage: rotateMsg , pipesLeft: pipesToSolve}\r\n      return outputObj\r\n    }\r\n  }\r\n};\r\n","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\options\\Options.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\header\\Header.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\rules\\Rules.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\cell\\Cell.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\fancyGrid\\FancyGrid.tsx",["72"],"import React, { FC } from \"react\";\nimport { WhatRender } from \"../../App\";\nimport { Pipe } from \"../../engine\";\nimport { Cell } from \"../cell/Cell\";\nimport Slider from \"../slider/Slider\";\nimport Spinner from \"../spinner/Spinner\";\nimport style from \"./fancyGrid.module.scss\";\n\ntype Props = {\n  grid: Pipe[][];\n  cellWidth: string;\n  xx: number;\n  yy: number;\n  level: number;\n  whatRender: WhatRender;\n  cellClickHandler: (x: number, y: number, pipe: Pipe) => void;\n  rightClickHandler: (\n    e: React.MouseEvent<HTMLDivElement, MouseEvent>,\n    x: number,\n    y: number\n  ) => void;\n};\n\nconst FancyGrid: FC<Props> = ({\n  grid,\n  cellWidth,\n  xx,\n  yy,\n  level,\n  whatRender,\n  cellClickHandler,\n  rightClickHandler,\n}) => {\n  const { fancyGrid, stopSolveBtn } = whatRender;\n\n  const showFancyGrid = () => {\n    if (fancyGrid && level > 2 && stopSolveBtn) {\n      return false;\n    }\n    if (fancyGrid) {\n      return true;\n    }\n    return false;\n  };\n  return (\n    <div className={style.fancyGrid}>\n      {fancyGrid && level > 2 && stopSolveBtn && <Spinner />}\n      {showFancyGrid() &&\n        grid.map((row, y) => {\n          return (\n            <div className={style.grid} key={`key${y}`}>\n              {row.map((pipe, x) => {\n                return (\n                  <div\n                    key={`key${y}${x}`}\n                    style={{ width: cellWidth, minWidth: \"30px\" }}\n                  >\n                    <Cell\n                      pipe={pipe}\n                      isActive={xx === x && yy === y}\n                      onClick={() => cellClickHandler(x, y, pipe)}\n                      onRightClick={(\n                        e: React.MouseEvent<HTMLDivElement, MouseEvent>\n                      ) => rightClickHandler(e, x, y)}\n                    />\n                  </div>\n                );\n              })}\n            </div>\n          );\n        })}\n    </div>\n  );\n};\n\nexport default FancyGrid;\n","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\simpleGrid\\SimpleGrid.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\spinner\\Spinner.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\slider\\Slider.tsx",["73"],"import React, { FC, useState } from \"react\";\nimport style from \"./slider.module.scss\";\n\ntype Props = {\n  min: number;\n  max: number;\n  value: number;\n  onChange: (value: number) => void;\n};\n\nconst Slider: FC<Props> = ({ min = 0, max = 4, value, onChange }) => {\n  return (\n    <div className='row'>\n      <div className='col-xs-2 end-xs col-xs-offset-1'>slower</div>\n      <div className='col-xs-6'>\n        <div className={style.slider}>\n          <input\n            className={style.range}\n            type='range'\n            min={min}\n            max={max}\n            value={value}\n            onChange={(e) => onChange(parseInt(e.target.value, 10))}\n          />\n        </div>\n      </div>\n      <div className='col-xs-2 start-xs'>faster</div>\n    </div>\n  );\n};\n\nexport default Slider;\n","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\button\\Button.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\resultsTable\\ResultsTable.tsx",["74"],"import React, { FC, useEffect, useState } from \"react\";\nimport style from \"./resultsTable.module.scss\";\n\ntype Props = {\n  verifyResponde: string;\n  currentLevel: number;\n  levels: number[];\n};\ninterface Results {\n  level: number;\n  password: string;\n}\nconst ResultsTable: FC<Props> = ({ verifyResponde, currentLevel, levels }) => {\n  const [results, setResults] = useState<Results[]>([]);\n\n  useEffect(() => {\n    const resultArr = levels.map((level) => {\n      return {\n        level,\n        password: \"\",\n      };\n    });\n    const storagePipes = JSON.parse(localStorage.pipesGame || \"[]\");\n    if (storagePipes.length) {\n      setResults(storagePipes);\n    } else {\n      setResults(resultArr);\n    }\n    if (verifyResponde.startsWith(\"verify: Correct\")) {\n      const resultsCopy = [...results];\n      const password = verifyResponde.split(\"verify: Correct! Password: \");\n      resultsCopy[currentLevel - 1].password = password[1];\n      setResults(resultsCopy);\n      localStorage.pipesGame = JSON.stringify(resultsCopy);\n    }\n  }, [verifyResponde]);\n\n  return (\n    <div className={style.results}>\n      {/* <h1>Passwords</h1> */}\n      <table>\n        <thead>\n          <tr>\n            <th>Level</th>\n            <th>Password</th>\n          </tr>\n        </thead>\n        <tbody>\n          {results.map(({ level, password }, index) => (\n            <tr key={level}>\n              <td>{index + 1}</td>\n              <td>{password}</td>\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n};\n\nexport default ResultsTable;\n","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\verify\\Verify.tsx",[],{"ruleId":"75","replacedBy":"76"},{"ruleId":"77","replacedBy":"78"},{"ruleId":"79","severity":1,"message":"80","line":85,"column":9,"nodeType":"81","messageId":"82","endLine":85,"endColumn":18},{"ruleId":"83","severity":1,"message":"84","line":140,"column":6,"nodeType":"85","endLine":140,"endColumn":26,"suggestions":"86"},{"ruleId":"79","severity":1,"message":"87","line":549,"column":7,"nodeType":"81","messageId":"82","endLine":549,"endColumn":42},{"ruleId":"79","severity":1,"message":"88","line":5,"column":8,"nodeType":"81","messageId":"82","endLine":5,"endColumn":14},{"ruleId":"79","severity":1,"message":"89","line":1,"column":21,"nodeType":"81","messageId":"82","endLine":1,"endColumn":29},{"ruleId":"83","severity":1,"message":"90","line":36,"column":6,"nodeType":"85","endLine":36,"endColumn":17,"suggestions":"91"},"no-native-reassign",["92"],"no-negated-in-lhs",["93"],"@typescript-eslint/no-unused-vars","'byteCount' is assigned a value but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'autoSolveTime', 'grid', 'stopAutoSolve', and 'verifyMsg'. Either include them or remove the dependency array.","ArrayExpression",["94"],"'isDoneAndConnectedSpecificDirection' is assigned a value but never used.","'Slider' is defined but never used.","'useState' is defined but never used.","React Hook useEffect has missing dependencies: 'currentLevel', 'levels', and 'results'. Either include them or remove the dependency array.",["95"],"no-global-assign","no-unsafe-negation",{"desc":"96","fix":"97"},{"desc":"98","fix":"99"},"Update the dependencies array to be: [counter, autoSolve, grid, autoSolveTime, verifyMsg, stopAutoSolve]",{"range":"100","text":"101"},"Update the dependencies array to be: [currentLevel, levels, results, verifyMsg]",{"range":"102","text":"103"},[3747,3767],"[counter, autoSolve, grid, autoSolveTime, verifyMsg, stopAutoSolve]",[1019,1030],"[currentLevel, levels, results, verifyMsg]"]
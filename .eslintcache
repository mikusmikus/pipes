[{"E:\\New folder\\pipes-task\\pipes-task\\src\\index.tsx":"1","E:\\New folder\\pipes-task\\pipes-task\\src\\reportWebVitals.ts":"2","E:\\New folder\\pipes-task\\pipes-task\\src\\App.tsx":"3","E:\\New folder\\pipes-task\\pipes-task\\src\\engine.ts":"4","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\options\\Options.tsx":"5","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\header\\Header.tsx":"6","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\rules\\Rules.tsx":"7","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\cell\\Cell.tsx":"8","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\fancyGrid\\FancyGrid.tsx":"9","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\simpleGrid\\SimpleGrid.tsx":"10","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\spinner\\Spinner.tsx":"11","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\slider\\Slider.tsx":"12","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\button\\Button.tsx":"13","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\resultsTable\\ResultsTable.tsx":"14","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\verify\\Verify.tsx":"15"},{"size":296,"mtime":1614208786438,"results":"16","hashOfConfig":"17"},{"size":425,"mtime":499158900000,"results":"18","hashOfConfig":"17"},{"size":10404,"mtime":1614596076768,"results":"19","hashOfConfig":"17"},{"size":20268,"mtime":1614603604555,"results":"20","hashOfConfig":"17"},{"size":1990,"mtime":1614540912013,"results":"21","hashOfConfig":"17"},{"size":851,"mtime":1614533979257,"results":"22","hashOfConfig":"17"},{"size":1502,"mtime":1614456155579,"results":"23","hashOfConfig":"17"},{"size":1063,"mtime":1614533442739,"results":"24","hashOfConfig":"17"},{"size":1769,"mtime":1614596097312,"results":"25","hashOfConfig":"17"},{"size":2038,"mtime":1614539916504,"results":"26","hashOfConfig":"17"},{"size":596,"mtime":1614533661341,"results":"27","hashOfConfig":"17"},{"size":784,"mtime":1614593603795,"results":"28","hashOfConfig":"17"},{"size":482,"mtime":1614505042883,"results":"29","hashOfConfig":"17"},{"size":1839,"mtime":1614510390746,"results":"30","hashOfConfig":"17"},{"size":1582,"mtime":1614521490984,"results":"31","hashOfConfig":"17"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},"1ctwnvw",{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"39","messages":"40","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46","usedDeprecatedRules":"34"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63","usedDeprecatedRules":"34"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},"E:\\New folder\\pipes-task\\pipes-task\\src\\index.tsx",[],["66","67"],"E:\\New folder\\pipes-task\\pipes-task\\src\\reportWebVitals.ts",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\App.tsx",["68"],"E:\\New folder\\pipes-task\\pipes-task\\src\\engine.ts",["69"],"export interface Pipe {\r\n  name: ShapeName;\r\n  top: boolean;\r\n  right: boolean;\r\n  bottom: boolean;\r\n  left: boolean;\r\n  isDone: boolean;\r\n  allowedPositions: Position[];\r\n  position: Position;\r\n}\r\n\r\nexport type Position = 0 | 90 | 180 | 270;\r\n\r\nexport type Direction = \"top\" | \"right\" | \"bottom\" | \"left\";\r\n\r\nexport type ShapeType =\r\n  | \"┏\"\r\n  | \"┓\"\r\n  | \"┗\"\r\n  | \"┛\"\r\n  | \"╸\"\r\n  | \"╺\"\r\n  | \"╹\"\r\n  | \"╻\"\r\n  | \"┣\"\r\n  | \"┳\"\r\n  | \"┻\"\r\n  | \"┫\"\r\n  | \"━\"\r\n  | \"┃\"\r\n  | \"╋\";\r\n\r\ntype ShapeName = \"Line\" | \"Elbow\" | \"Tee\" | \"End\" | \"Cross\" ;\r\n\r\ninterface Output  {\r\n  rotateMessage: string , pipesLeft: number\r\n}\r\n\r\nexport const splitRawDataInShapeRows = (\r\n  mapAsString: string,\r\n): string[] => {\r\n  const legitMapData = mapAsString.split(\"\\n\");\r\n    legitMapData.shift();\r\n    legitMapData.pop();\r\n  return legitMapData;\r\n};\r\n\r\nexport const makeShapeGridFromRows = (rows: string[]): ShapeType[][] => {\r\n  const output: ShapeType[][] = rows.map((row) => {\r\n    return row.split(\"\") as ShapeType[];\r\n  });\r\n  return output;\r\n};\r\n\r\nexport const initNewPipe = (\r\n  name: ShapeName,\r\n  top: boolean,\r\n  right: boolean,\r\n  bottom: boolean,\r\n  left: boolean,\r\n  position: Position,\r\n): Pipe => {\r\n  return {\r\n    name,\r\n    top,\r\n    right,\r\n    bottom,\r\n    left,\r\n    position,\r\n    isDone: name === \"Cross\" ? true : false,\r\n    allowedPositions: name === \"Cross\" ? [0] : [0, 90, 180, 270],\r\n  };\r\n};\r\n\r\nexport const translateFromShapeToPipe = (\r\n  shape: ShapeType\r\n): Pipe => {\r\n  switch (shape) {\r\n    case \"┗\": {\r\n      return initNewPipe(\"Elbow\", true, true, false, false, 0);\r\n    }\r\n    case \"┏\": {\r\n      return initNewPipe(\"Elbow\", false, true, true, false, 90);\r\n    }\r\n    case \"┓\": {\r\n      return initNewPipe(\"Elbow\", false, false, true, true, 180);\r\n    }\r\n    case \"┛\": {\r\n      return initNewPipe(\"Elbow\", true, false, false, true, 270);\r\n    }\r\n    case \"╹\": {\r\n      return initNewPipe(\"End\", true, false, false, false, 0);\r\n    }\r\n    case \"╺\": {\r\n      return initNewPipe(\"End\", false, true, false, false, 90);\r\n    }\r\n    case \"╻\": {\r\n      return initNewPipe(\"End\", false, false, true, false, 180);\r\n    }\r\n    case \"╸\": {\r\n      return initNewPipe(\"End\", false, false, false, true, 270);\r\n    }\r\n    case \"┻\": {\r\n      return initNewPipe(\"Tee\", true, true, false, true, 0);\r\n    }\r\n    case \"┣\": {\r\n      return initNewPipe(\"Tee\", true, true, true, false, 90);\r\n    }\r\n    case \"┳\": {\r\n      return initNewPipe(\"Tee\", false, true, true, true, 180);\r\n    }\r\n    case \"┫\": {\r\n      return initNewPipe(\"Tee\", true, false, true, true, 270);\r\n    }\r\n    case \"┃\": {\r\n      return initNewPipe(\"Line\", true, false, true, false, 0);\r\n    }\r\n    case \"━\": {\r\n      return initNewPipe(\"Line\", false, true, false, true, 90);\r\n    }\r\n    case \"╋\": {\r\n      return initNewPipe(\"Cross\", true, true, true, true, 0);\r\n    }\r\n    default: {\r\n      return initNewPipe(\"Cross\", false, false, false, false, 0);\r\n    }\r\n  }\r\n};\r\nexport const translateFromPipeToShape = (pipe: Pipe): ShapeType => {\r\n  const { top, right, bottom, left } = pipe;\r\n  const pipePositions = [top, right, bottom, left];\r\n  switch (JSON.stringify(pipePositions)) {\r\n    case JSON.stringify([false, true, true, false]):\r\n      return \"┏\";\r\n    case JSON.stringify([false, false, true, true]):\r\n      return \"┓\";\r\n    case JSON.stringify([true, false, false, true]):\r\n      return \"┛\";\r\n    case JSON.stringify([true, true, false, false]):\r\n      return \"┗\";\r\n    case JSON.stringify([true, false, true, false]):\r\n      return \"┃\";\r\n    case JSON.stringify([false, true, false, true]):\r\n      return \"━\";\r\n    case JSON.stringify([true, false, true, true]):\r\n      return \"┫\";\r\n    case JSON.stringify([true, true, true, false]):\r\n      return \"┣\";\r\n    case JSON.stringify([true, true, false, true]):\r\n      return \"┻\";\r\n    case JSON.stringify([false, true, true, true]):\r\n      return \"┳\";\r\n    case JSON.stringify([false, false, false, true]):\r\n      return \"╸\";\r\n    case JSON.stringify([false, false, true, false]):\r\n      return \"╻\";\r\n    case JSON.stringify([false, true, false, false]):\r\n      return \"╺\";\r\n    case JSON.stringify([true, false, false, false]):\r\n      return \"╹\";\r\n    case JSON.stringify([true, true, true, true]):\r\n      return \"╋\";\r\n    default:\r\n      return \"╋\";\r\n  }\r\n};\r\n\r\nexport const transformShapeGridToPipeGrid = (\r\n  shapeGrid: ShapeType[][]\r\n): Pipe[][] => {\r\n  const output = shapeGrid.map((row) => {\r\n    return row.map((shape) => {\r\n      return translateFromShapeToPipe(shape);\r\n    });\r\n  });\r\n  return output;\r\n};\r\n\r\nexport const rotatePipe = (pipe: Pipe): Pipe => {\r\n  const output = { ...pipe };\r\n  output.top = pipe.left;\r\n  output.left = pipe.bottom;\r\n  output.bottom = pipe.right;\r\n  output.right = pipe.top;\r\n  if (output.position > 200) {\r\n    output.position = 0;\r\n  } else {\r\n    output.position += 90;\r\n  }\r\n  return output;\r\n};\r\n\r\nexport const appendRotateMessage = (\r\n  base: string,\r\n  x: number,\r\n  y: number\r\n): string => {\r\n  if (base.length > 8) {\r\n    return (base += `\\n${x} ${y}`);\r\n  }\r\n  return (base += ` ${x} ${y}`);\r\n};\r\n\r\nexport const calculateRotationCount = (\r\n  positionNow: Position,\r\n  desiredPosition: Position\r\n): number => {\r\n  let output = 0;\r\n  let tmp = positionNow;\r\n  while (tmp !== desiredPosition) {\r\n    output += 1;\r\n    if (tmp > 200) {\r\n      tmp = 0;\r\n    } else {\r\n      tmp += 90;\r\n    }\r\n  }\r\n  return output;\r\n};\r\n\r\n// Check if pipe must be NOT connected given direction even if it's not done\r\nexport const mustBeNotConnected = (\r\n  x: number,\r\n  y: number,\r\n  direction: Direction,\r\n  grid: Pipe[][]\r\n): boolean => {\r\n  const pipe = grid[y][x];\r\n  // if all pipes posotions possible, then it's not certain and return false\r\n  if (pipe.allowedPositions.length > 3) return false;\r\n\r\n  let output = true;\r\n  const positionNow = pipe.position;\r\n  \r\n  pipe.allowedPositions.forEach((posAllowed) => {\r\n    const count = calculateRotationCount(positionNow, posAllowed);\r\n    let tmpPipe = { ...pipe };\r\n    for (let i = 0; i < count; i++) {\r\n      tmpPipe = rotatePipe(tmpPipe);\r\n    }\r\n    if (tmpPipe[direction]) output = false;\r\n  });\r\n  return output;\r\n};\r\n\r\n// Check if pipe must be connected given direction even if it's not done\r\nexport const mustBeConnected = (\r\n  x: number,\r\n  y: number,\r\n  direction: Direction,\r\n  grid: Pipe[][]\r\n): boolean => {\r\n  const pipe = grid[y][x];\r\n\r\n  if (pipe.allowedPositions.length > 3) return false;\r\n\r\n  let output = true;\r\n  const positionNow = pipe.position;\r\n  pipe.allowedPositions.forEach((posAllowed) => {\r\n    const count = calculateRotationCount(positionNow, posAllowed);\r\n    let tmpPipe = { ...pipe };\r\n    for (let i = 0; i < count; i++) {\r\n      tmpPipe = rotatePipe(tmpPipe);\r\n      \r\n    }\r\n    if (!tmpPipe[direction]) output = false;\r\n  });\r\n\r\n  return output;\r\n};\r\n\r\n// Removes given positions from positions array and returns updated positions array\r\nexport const spliceOutPositions = (\r\n  allowdPositons: Position[],\r\n  ...positionsToRemove: Position[]\r\n): Position[] => {\r\n  const output = [...allowdPositons];\r\n  positionsToRemove.forEach((pos) => {\r\n    const idx = output.indexOf(pos);\r\n    if (idx > -1) output.splice(idx, 1);\r\n  });\r\n  return output;\r\n};\r\n\r\n// --------------- CHECK LINE SHAPE -------------\r\n\r\nexport const checkLeft_Line = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const leftPipe = grid[y][x - 1];\r\n  // If there is no pipe on the left, reduce to single possible position\r\n  if (!leftPipe) return [0];\r\n  // If left pipe does not allow right connection, reduce to single possible position\r\n  if (mustBeNotConnected(x - 1, y, \"right\", grid)) return [0];\r\n  // If left pipe must have right connection, reduce to single possible position\r\n  if (mustBeConnected(x - 1, y, \"right\", grid)) return [90];\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkRight_Line = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const rightPipe = grid[y][x + 1];\r\n  if (!rightPipe) return [0];\r\n  if (mustBeConnected(x + 1, y, \"left\", grid)) return [90];\r\n  if (mustBeNotConnected(x + 1, y, \"left\", grid)) return [0];\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkTop_Line = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y - 1 < 0) return [90];\r\n  if (mustBeConnected(x, y - 1, \"bottom\", grid)) return [0];\r\n  if (mustBeNotConnected(x, y - 1, \"bottom\", grid)) return [90];\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkBottom_Line = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y + 1 >= grid.length) return [90];\r\n  if (mustBeConnected(x, y + 1, \"top\", grid)) return [0];\r\n  if (mustBeNotConnected(x, y + 1, \"top\", grid)) return [90];\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\n// --------------- CHECK TEE SHAPE -------------\r\n\r\nexport const checkLeft_Tee = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const leftPipe = grid[y][x - 1];\r\n  // If there is no pipe on the left, reduce to single possible position\r\n  if (!leftPipe) return [90];\r\n  // If left pipe does not allow right connection, reduce to single possible position\r\n  if (mustBeNotConnected(x - 1, y, \"right\", grid)) return [90];\r\n  // If left pipe must have right connection, slice out one not possible connection\r\n  if (mustBeConnected(x - 1, y, \"right\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkRight_Tee = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const rightPipe = grid[y][x + 1];\r\n  if (!rightPipe) return [270];\r\n  if (mustBeNotConnected(x + 1, y, \"left\", grid)) return [270];\r\n  if (mustBeConnected(x + 1, y, \"left\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 270);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkTop_Tee = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y - 1 < 0) return [180];\r\n  if (mustBeNotConnected(x, y - 1, \"bottom\", grid)) return [180];\r\n  if (mustBeConnected(x, y - 1, \"bottom\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkBottom_Tee = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y + 1 >= grid.length) return [0];\r\n  if (mustBeNotConnected(x, y + 1, \"top\", grid)) return [0];\r\n  if (mustBeConnected(x, y + 1, \"top\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\n// --------------- CHECK END SHAPE -------------\r\n\r\nexport const checkLeft_End = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const leftPipe = grid[y][x - 1];\r\n  // If there is no pipe on the left, slice out one not possible position\r\n  if (!leftPipe) return spliceOutPositions(grid[y][x].allowedPositions, 270);\r\n  // If left pipe must NOT be connected to right, slice out one not possible position\r\n  if (mustBeNotConnected(x - 1, y, \"right\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 270);\r\n  // If left pipe must be connected to right, reduce to one possible connection\r\n  if (mustBeConnected(x - 1, y, \"right\", grid)) return [270];\r\n  // If left pipe is End too, slice out one not possible direction\r\n  else if (leftPipe.name === \"End\")\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 270);\r\n  // if no pattern found\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkRight_End = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const rightPipe = grid[y][x + 1];\r\n  if (!rightPipe) return spliceOutPositions(grid[y][x].allowedPositions, 90);\r\n  if (mustBeNotConnected(x + 1, y, \"left\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90);\r\n  if (mustBeConnected(x + 1, y, \"left\", grid)) return [90];\r\n  else if (rightPipe.name === \"End\")\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkTop_End = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y - 1 < 0) return spliceOutPositions(grid[y][x].allowedPositions, 0);\r\n  if (mustBeNotConnected(x, y - 1, \"bottom\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0);\r\n  if (mustBeConnected(x, y - 1, \"bottom\", grid)) return [0];\r\n  else if (grid[y - 1][x].name === \"End\")\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkBottom_End = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y + 1 >= grid.length)\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180);\r\n  if (mustBeNotConnected(x, y + 1, \"top\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180);\r\n  if (mustBeConnected(x, y + 1, \"top\", grid)) return [180];\r\n  else if (grid[y + 1][x].name === \"End\")\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180);\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\n// --------------- CHECK ELBOW SHAPE -------------\r\n\r\nexport const checkLeft_Elbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const leftPipe = grid[y][x - 1];\r\n  // If there is no pipe on the left, slice out two not possible positions\r\n  if (!leftPipe)\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180, 270);\r\n  // If left pipe cant have right connection, slice out two not possible positions\r\n  if (mustBeNotConnected(x - 1, y, \"right\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180, 270);\r\n  // If left pipe must have right connection, slice out two not possible positions\r\n  if (mustBeConnected(x - 1, y, \"right\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0, 90);\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkRight_Elbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  const rightPipe = grid[y][x + 1];\r\n  if (!rightPipe) return spliceOutPositions(grid[y][x].allowedPositions, 0, 90);\r\n  if (mustBeNotConnected(x + 1, y, \"left\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0, 90);\r\n  if (mustBeConnected(x + 1, y, \"left\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 180, 270);\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkTop_Elbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y - 1 < 0) return spliceOutPositions(grid[y][x].allowedPositions, 0, 270);\r\n  if (mustBeNotConnected(x, y - 1, \"bottom\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0, 270);\r\n  if (mustBeConnected(x, y - 1, \"bottom\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90, 180);\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\nexport const checkBottom_Elbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][]\r\n): Position[] => {\r\n  if (y + 1 >= grid.length)\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90, 180);\r\n  if (mustBeNotConnected(x, y + 1, \"top\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 90, 180);\r\n  if (mustBeConnected(x, y + 1, \"top\", grid))\r\n    return spliceOutPositions(grid[y][x].allowedPositions, 0, 270);\r\n\r\n  return grid[y][x].allowedPositions;\r\n};\r\n\r\n\r\nexport const solvePipe = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][],\r\n  rotateMsg: string,\r\n  pipesToSolve: number\r\n\r\n): Output => {\r\n  let output = rotateMsg;\r\n  let pipesLeft = pipesToSolve;\r\n\r\n  \r\n  const count = calculateRotationCount(\r\n    grid[y][x].position,\r\n    grid[y][x].allowedPositions[0]\r\n  );\r\n  for (let i = 0; i < count; i++) {\r\n    grid[y][x] = rotatePipe(grid[y][x]);\r\n    output = appendRotateMessage(output, x, y);\r\n  }\r\n  grid[y][x].isDone = true;\r\n  pipesLeft -=1;\r\n  \r\n  const outputObj = {rotateMessage: output , pipesLeft}\r\n  return outputObj\r\n};\r\n\r\n\r\nconst isDoneAndConnectedSpecificDirection = (\r\n  x: number,\r\n  y: number,\r\n  direction: Direction,\r\n  grid: Pipe[][]\r\n) => {\r\n  // If passed not legit coordinates\r\n  if (x < 0 || y < 0 || x >= grid[0].length || y >= grid.length) return false;\r\n  // If pipe is not done\r\n  if (!grid[y][x].isDone) return false;\r\n  // if pipe is connected given direction\r\n  if (grid[y][x][direction]) return true;\r\n  // else false\r\n  return false;\r\n};\r\n\r\nconst checkLine = (x: number, y: number, grid: Pipe[][], rotateMsg: string, pipesToSolve:number):Output => {\r\n  let output = rotateMsg;\r\n  grid[y][x].allowedPositions = checkLeft_Line(x, y, grid);\r\n  grid[y][x].allowedPositions = checkRight_Line(x, y, grid);\r\n  grid[y][x].allowedPositions = checkTop_Line(x, y, grid);\r\n  grid[y][x].allowedPositions = checkBottom_Line(x, y, grid);\r\n  if (grid[y][x].allowedPositions.length === 1) {\r\n     return  solvePipe(x, y, grid, output, pipesToSolve);\r\n  }\r\n  const outputObj =  {rotateMessage: output , pipesLeft: pipesToSolve}\r\n  return outputObj\r\n};\r\n\r\nconst checkTee = (x: number, y: number, grid: Pipe[][], rotateMsg: string, pipesToSolve:number):Output => {\r\n  let output = rotateMsg;\r\n  grid[y][x].allowedPositions = checkLeft_Tee(x, y, grid);\r\n  grid[y][x].allowedPositions = checkRight_Tee(x, y, grid);\r\n  grid[y][x].allowedPositions = checkTop_Tee(x, y, grid);\r\n  grid[y][x].allowedPositions = checkBottom_Tee(x, y, grid);\r\n  if (grid[y][x].allowedPositions.length === 1) {\r\n     return  solvePipe(x, y, grid, output, pipesToSolve);\r\n  }\r\n  const outputObj =  {rotateMessage: output , pipesLeft: pipesToSolve}\r\n  return outputObj\r\n};\r\n\r\nconst checkEnd = (x: number, y: number, grid: Pipe[][], rotateMsg: string, pipesToSolve:number) => {\r\n  let output = rotateMsg;\r\n  grid[y][x].allowedPositions = checkLeft_End(x, y, grid);\r\n  grid[y][x].allowedPositions = checkRight_End(x, y, grid);\r\n  grid[y][x].allowedPositions = checkTop_End(x, y, grid);\r\n  grid[y][x].allowedPositions = checkBottom_End(x, y, grid);\r\n  if (grid[y][x].allowedPositions.length === 1) {\r\n     return  solvePipe(x, y, grid, output, pipesToSolve);\r\n  }\r\n  const outputObj =  {rotateMessage: output , pipesLeft: pipesToSolve}\r\n  return outputObj\r\n};\r\n\r\nconst checkElbow = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][],\r\n  rotateMsg: string, \r\n  pipesToSolve:number\r\n) => {\r\n  let output = rotateMsg;\r\n  grid[y][x].allowedPositions = checkLeft_Elbow(x, y, grid);\r\n  grid[y][x].allowedPositions = checkRight_Elbow(x, y, grid);\r\n  grid[y][x].allowedPositions = checkTop_Elbow(x, y, grid);\r\n  grid[y][x].allowedPositions = checkBottom_Elbow(x, y, grid);\r\n  if (grid[y][x].allowedPositions.length === 1) {\r\n    return  solvePipe(x, y, grid, output, pipesToSolve);\r\n  }\r\n  const outputObj =  {rotateMessage: output , pipesLeft: pipesToSolve}\r\n  return outputObj\r\n};\r\n\r\nexport const checkPipe = (\r\n  x: number,\r\n  y: number,\r\n  grid: Pipe[][],\r\n  rotateMsg: string,\r\n  pipesToSolve : number\r\n): {rotateMessage : string, pipesLeft : number} => {\r\n  switch (grid[y][x].name) {\r\n    case \"Line\": {\r\n      return checkLine(x, y, grid, rotateMsg, pipesToSolve);\r\n    }\r\n    case \"Tee\": {\r\n      return checkTee(x, y, grid, rotateMsg, pipesToSolve);\r\n    }\r\n    case \"End\": {\r\n      return checkEnd(x, y, grid, rotateMsg, pipesToSolve);\r\n    }\r\n    case \"Elbow\": {\r\n      return checkElbow(x, y, grid, rotateMsg, pipesToSolve);\r\n    }\r\n    default: {\r\n      const outputObj =  {rotateMessage: rotateMsg , pipesLeft: pipesToSolve}\r\n      return outputObj\r\n    }\r\n  }\r\n};\r\n\r\n\r\nexport const findNextCoordinates = (\r\n  count: number,\r\n  totalPipes: number,\r\n  xx: number,\r\n  yy: number,\r\n  grid: Pipe[][]\r\n):{x: number, y: number} => {\r\n  let loopCountLeft = totalPipes;\r\n  let keepLooping = true;\r\n  let x = xx;\r\n  let y = yy;\r\n\r\n  do {\r\n    if (count) {\r\n      x += 1;\r\n    }\r\n    if (x >= grid[0].length) {\r\n      x = 0;\r\n      y += 1;\r\n    }\r\n    if (y >= grid.length) {\r\n      y = 0;\r\n      x = 0;\r\n    }\r\n\r\n    if (!grid[y][x].isDone) {\r\n      keepLooping = false;\r\n    }\r\n\r\n    loopCountLeft -= 1;\r\n    if (loopCountLeft < 0) {\r\n      keepLooping = false;\r\n    }\r\n  } while (keepLooping);\r\n  return { x, y };\r\n};\r\n\r\n\r\n// check if solved pipe have open directions\r\nexport const checkSolvedPipeSides = () => {\r\n\r\n}","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\options\\Options.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\header\\Header.tsx",["70"],"import React, { useState, useEffect } from \"react\";\nimport Button from \"../button/Button\";\nimport style from \"./header.module.scss\";\nimport Rules from \"./../rules/Rules\";\n\nconst Header = () => {\n  const [showRules, setShowRules] = useState(false);\n  return (\n    <>\n      <Rules showRules={showRules} onRulesClick={() => setShowRules(false)} />\n\n      <div className='row'>\n        <div className='col-sm-9 col-xs-12'>\n          <h1 className={style.heading}>PIPE GAME</h1>\n        </div>\n        <div className='col-xs-3 center-xs middle-xs'>\n          {!showRules && (\n            <div className={style.buttonWrapper}>\n              <Button size='medium' onClick={() => setShowRules(!showRules)}>\n                How to play\n              </Button>\n            </div>\n          )}\n        </div>\n      </div>\n    </>\n  );\n};\n\nexport default Header;\n","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\rules\\Rules.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\cell\\Cell.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\fancyGrid\\FancyGrid.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\simpleGrid\\SimpleGrid.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\spinner\\Spinner.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\slider\\Slider.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\button\\Button.tsx",[],"E:\\New folder\\pipes-task\\pipes-task\\src\\components\\resultsTable\\ResultsTable.tsx",["71"],"import React, { FC, useEffect, useState } from \"react\";\nimport { WhatRender } from \"../../App\";\nimport style from \"./resultsTable.module.scss\";\n\ntype Props = {\n  verifyResponde: string;\n  currentLevel: number;\n  levels: number[];\n  whatRender: WhatRender;\n};\ninterface Results {\n  level: number;\n  password: string;\n}\nconst ResultsTable: FC<Props> = ({\n  verifyResponde,\n  currentLevel,\n  levels,\n  whatRender,\n}) => {\n  const [results, setResults] = useState<Results[]>([]);\n  const { levelsBtns, startGameBtn } = whatRender;\n  useEffect(() => {\n    const resultArr = levels.map((level) => {\n      return {\n        level,\n        password: \"\",\n      };\n    });\n    const storagePipes = JSON.parse(localStorage.pipesGame || \"[]\");\n    if (storagePipes.length) {\n      setResults(storagePipes);\n    } else {\n      setResults(resultArr);\n    }\n    if (verifyResponde.startsWith(\"verify: Correct\")) {\n      const resultsCopy = [...results];\n      const password = verifyResponde.split(\"verify: Correct! Password: \");\n      resultsCopy[currentLevel - 1].password = password[1];\n      setResults(resultsCopy);\n      localStorage.pipesGame = JSON.stringify(resultsCopy);\n    }\n    \n  }, [verifyResponde]);\n\n  return (\n    <>\n      {(startGameBtn || levelsBtns) && (\n        <div className={style.results}>\n          <table>\n            <thead>\n              <tr>\n                <th>Level</th>\n                <th>Password</th>\n              </tr>\n            </thead>\n            <tbody>\n              {results.map(({ level, password }, index) => (\n                <tr key={level} className={password && style.done}>\n                  <td>{index + 1}</td>\n                  <td>{password}</td>\n                </tr>\n              ))}\n            </tbody>\n          </table>\n        </div>\n      )}\n    </>\n  );\n};\n\nexport default ResultsTable;\n","E:\\New folder\\pipes-task\\pipes-task\\src\\components\\verify\\Verify.tsx",[],{"ruleId":"72","replacedBy":"73"},{"ruleId":"74","replacedBy":"75"},{"ruleId":"76","severity":1,"message":"77","line":126,"column":6,"nodeType":"78","endLine":126,"endColumn":26,"suggestions":"79"},{"ruleId":"80","severity":1,"message":"81","line":552,"column":7,"nodeType":"82","messageId":"83","endLine":552,"endColumn":42},{"ruleId":"80","severity":1,"message":"84","line":1,"column":27,"nodeType":"82","messageId":"83","endLine":1,"endColumn":36},{"ruleId":"76","severity":1,"message":"85","line":44,"column":6,"nodeType":"78","endLine":44,"endColumn":22,"suggestions":"86"},"no-native-reassign",["87"],"no-negated-in-lhs",["88"],"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'autoSolveTime', 'grid', 'stopAutoSolve', and 'verifyMsg'. Either include them or remove the dependency array.","ArrayExpression",["89"],"@typescript-eslint/no-unused-vars","'isDoneAndConnectedSpecificDirection' is assigned a value but never used.","Identifier","unusedVar","'useEffect' is defined but never used.","React Hook useEffect has missing dependencies: 'currentLevel', 'levels', and 'results'. Either include them or remove the dependency array.",["90"],"no-global-assign","no-unsafe-negation",{"desc":"91","fix":"92"},{"desc":"93","fix":"94"},"Update the dependencies array to be: [counter, autoSolve, grid, autoSolveTime, verifyMsg, stopAutoSolve]",{"range":"95","text":"96"},"Update the dependencies array to be: [currentLevel, levels, results, verifyResponde]",{"range":"97","text":"98"},[3451,3471],"[counter, autoSolve, grid, autoSolveTime, verifyMsg, stopAutoSolve]",[1181,1197],"[currentLevel, levels, results, verifyResponde]"]